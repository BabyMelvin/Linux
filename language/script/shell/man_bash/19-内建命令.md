# shell 内建命令(SHELL BUILTIN COMMANDS)
除非另外说明，这一章介绍的内建命令如果接受`-`引导的选项，那么它也接受`--`作为参数，来指示选项的结束

# `: [arguments]`

没有效果；这个命令除了扩展 arguments 并且作任何指定的重定向之外，不做任何事。退出时返回0。

# `.  filename [arguments]`和`source filename [arguments]`

读取并在当前 shell 环境中执行 filename 中的命令，返回filename中最后一个命令的返回状态。

* 如果 filename 中不包含`斜杠`(slash)，系统将在PATH中查找包含filename的目录。在 PATH 中搜索的文件不必是可执行的。如果 bash 不是运行于 posix mode，当 PATH 中找不到文件时会在当前目录搜索。
  * 如果 shopt 内建命令的 sourcepath 选项被关闭， PATH 将不会被搜索。
* 如果有任何 arguments ，它们成为 filename的位置参数 (positional parameters)，否则位置参数不发生变化。
* 返回状态是脚本中最后一个命令退出时的状态。没有执行命令则返回0，没有找到或不能读取 filename 时返回false。

# `alias [-p] [name[=value] ...]`

Alias 不带参数或者带 -p 参数运行时将在标准输出以这样的格式 `alias name=value`给出别名列表。

* 如果有参数，将创建提供了value的name的别名。value 中尾部的空格使得别名被扩展时，下一个词做别名替 换。
* 对于参数列表中的每一个 name，如果 value 没有给出，这个别名的名称和值会被打印出来。 Alias 返回 true 除非 name 没有定义为别名。

# `bg [jobspec]`

使挂起的程序 jobspec 在后台继续执行，就好像它是用 & 启动的一样。如果没有指定 jobspec，shell 意义上的 current job 当前作业 将被使用。 `bg jobspec` 返回0，除非当前禁止了作业控制，或者在允许作业 控制，但是没有找到 jobspec ，或者它不是在作业控制下启动的时候。

# `break [n]`
从一个 for, while, until, 或者 select 循环退出。如果指定了 n  ，就 跳出 n 层循环。 n 必须 ≥ 1。如果 n 比当前循环层数还要大，将跳出所有循环。返回值是0，除非执行 break 的时候 shell 不是在执行 一个循环。

# ` cd [-L|-P] [dir]`
改变当前路径到 dir。这个变量的默认值是 HOME 目 录 。 环境变量CDPATH定义了包含 dir 的搜索路径。在 CDPATH 中可选的路径名以冒号(:) 分隔。 CDPATH 中的空路径名与当前路径相同，就是 ‘‘.’’.   如果 目录名以斜杠 (/,slash) 起始，那么 CDPATH 不会被使用。 -P 选项是说使用物理路径结构而不是跟随符号链接，(参见 set 命令中的 -P 选项); -L 选项强制跟随符号链接。另外，选项 - 与 $OLDPWD 是相同的。返回值是 true ，如果成功地改变了目录；否则是 false。

# `command [-pVv] command [arg ...]`
运行 command ，使用 args 作为参数，禁止通常的查找 shell 函数的过程。只有内建命令或者 PATH 中包含的命令可以执行。如果给出 -p 参数， command 的查找是以 PATH 的默认值进行的。这样可以保证找到所 有 的 标准工具。如果给出 -V 或者 -v 选项，关于 command 的说明将被打印出来。 -v 选项使得表述这个命令的词，或者要执行 command 需要 执行 的文件显示出来； -V 选项给出更详细的描述。如果给出 -V 或者 -v选项，退出状态在找到了 command 的情况下0，没找到就是1。如果没有提供选项，并且产生了错误或者 command 没有找到，退出状态就是127。否则， command 内建命令的退出状态是 command 的退出状态。

# `continue [n]`
复位到外层 for, while, until, 或 select 循环的下一次开始。如果指定 了 n，复位到向外第 n 层循环的开始。 n 必须 ≥ 1。如果 n 比外部循环的层数要多，将复位到最外层的循环 (‘‘top-level’’ loop，顶层循环)。返回值是 0，除非执行 continue 时，shell 不是在循环之中。

# `declare [-afFirtx] [-p] [name[=value]]`和` typeset [-afFirtx] [-p] [name[=value]]`

声 明变量且/或设置它们的属性。如果没有给出 name 则显示变量的值。选项 -p 将显示每个名称 name 的属性和值。当使用 -p 时，其他选项被忽略。选项 -F 禁止显示函数定义；只有函数名和属性会被显示。 -F 选项暗含 -f.  下列选项可用来限制只输出具有指定属性的变量，或者为变量设置属性：

* -a:每个name都是数组变量 (参见上面的 Arrays 段落)。
* -f:只使用函数名。
* -i:变量被当作一个整数；当变量被赋值时将进行算术运算 (参见算术求值 (ARITHMETIC EVALUATION) 章节)。
* -r:使得 name 只读。这些名称不能再被后续的赋值语句赋值或取消定义。
* -t:设置每个 name 的 trace(跟踪) 属性。被跟踪的函数继承了调用者 shell 的 DEBUG 陷阱。trace 属性对变量没有特殊意义。
*  -x:标记 name 为可以通过环境导出给后续命令。

使用 ‘+’ 代替 ‘-’ 将关闭属性，特殊情况是 +a 不能用于销毁一个数组变 量 。 当 用于函数中时，它使得每个 name 成为局部的，就像使用了local 命令。返回值是 0，除非遇到了非法的选项， 试 图 使 用  ‘‘-f foo=bar’’ 定义函数，试图向只读变量赋值，试图向数组变量赋值但没有使用复合的赋值语法 (参见上面的 Arrays 段落)，name 之一不是有效的shell 变量名，试图将数组变量的数组状态关闭，或者是试图使用 -f 显示一个不存在的函数。

# `dirs [-clpv] [+n] [-n]`
没有选项时显示当前保存的目录。默认输出为一行，目录名用空格分开。可 以使用 pushd 命令将目录添加到列表， popd 命令将列表中的条目删除。+n     显示 dirs 在不带选项执行时显示的列表的第 n 个条目， 从0开始自左算起。

* -n      显 示 dirs 在不带选项执行时显示的列表的第 n 个条目，从0开始自右算起。
* -c     删除所有条目，清空目录栈。
* -l     产生长列表；默认列表格式使用波浪线来表示个人目录。
* -p     输出目录栈，一行一个。
* -v     输出目录栈，一行一个，每个条目前面加上它在栈中的位置索 引。返 回值是 0，除非给出了非法的参数，或者 n 索引超出了目录栈的范围。

# `disown [-ar] [-h] [jobspec ...]`
没有选项时，每个 jobspec 被从正在运行的作业表中删除。如果给出了`-`选项，每个 jobspec 并不从表中删除，而是被标记，使得在 shell 接到 SIGHUP 信号时，不会向作业发出 SIGHUP 信号。 如 果 没 有 给 出jobspec ， 也 没 有给出 -a 或者 -r 选项，将使用当前作业 (currentjob)。如果没有给出 jobspec，选项 `-a` 意味着删除或标记所有作业；选项  `-r` 不带 jobspec 参数时限制操作只对正在运行的作业进行。返回值是 0，除非 jobspec 不指定有效的作业。
 
# `echo [-neE] [arg ...]`
输出 arg，以空格分开，最后加一个新行符。返回值总是 0。如果指定了-n，将不在尾部添加新行符。如果给出了 -e 选项，将允许解释下列反斜杠转义的字符。 -E 选项禁止这些转义字符的解释，即使在默认解释它们的系统中也是如此。 shell 选项 xpg_echo 可以用来在运行时判断 echo是否默认展开这些转义字符。 echo 不将 -- 作为选项的结束。 echo 解
         
释下列转义序列：
* `\a`     alert (bell) 响铃
* `\b`     backspace 回退
* `\c`     suppress trailing newline 删除尾部新行符
* `\e`     an escape character 字符 Esc
* `\f`     form feed 进纸
* `\n`     new line 新行符
* `\r`     carriage return 回车
* `\t`     horizontal tab 水平跳格
* `\v`     vertical tab 竖直跳格
* `\\`     backslash 反斜杠
* `\0nnn`  一个八比特字符，它的值是八进制值 nnn (零到三个八进制数字)。
* `\nnn`   一个八比特字符，它的值是八进制值 nnn (一到三个八进制数字)。
* `\xHH`   一个八比特字符，它的值是十六进制值 HH (一到两个十六进制数字)。
 
# `enable [-adnps] [-f filename] [name ...]`
          允许或禁止 shell 内建命令。禁止一个内建命令使得磁盘上的与内建 命
          令 同名的文件得以运行，不必使用它的全路径，即使 shell 一般在搜索
          磁盘上的命令之前搜索内建命令。如果使用了 -n 选项，每个 name 都被
          禁止；否则， name 被允许。例如，要使用 PATH 中搜索到的 test 命令
          而不是 shell 内建的那一个，可以运行 ‘‘enable -n test’’.  选项 -f
          意 味着从共享库 filename 中加载新的内建命令 name，如果系统支持动
          态加载的话。选项 -d 将删除曾经用 -f 加载的内建命令。如果没有给出
          name 参数，或者给出了 -p 选项，将显示 shell 内建命令的列表。如果
          没有其他选项参数，这个列表只包含所有被允许的 shell 内建命令； 如
          果给出了 -n，将只显示被禁止的内建命令；如果给出了 -a，显示的列表
          中包含所有内建命令，还有命令是否被允许的指示；如果给出了 -s， 输
          出 被 限 制为 POSIX special 内建命令。返回值是 0，除非 name 不是
          shell 内建命令，或者从共享库中加载新的内建命令时出错。
 
       eval [arg ...]
          arg 被读取并连结为单一的命令。这个命令然后被 shell 读取并执行 ，
          它 的退出状态被作为 eval 的值返回。如果没有 args，或仅仅包含空参
          数， eval 返回 0。
 
       exec [-cl] [-a name] [command [arguments]]
          如果指定了 command，它将替换 shell。不会产生新的进程。 arguments
          成 为  command 的参数。如果给出了 -l 选项，shell 将在传递给 com-
          mand 的第 0 个参数前面加上一个连字 符  (dash,‘-’) 。 这 样 做 和
          login(1) 相同。选项 -c 使得命令 command 在一个空环境中执行。如果
          给出了 -a， shell 会将 name 作为第 0 个参数传递给要执行的命令 。
          如果由于某种原因 as the zeroth argument to the executed command.
          If command 不能被执行，非交互的 shell 将退出，除非 shell   选 项
          execfail  被设置为允许，这种情况下它返回失败。如果命令不能执行，
          交互的 shell 返回失败。如果没有指定 command 任何重定 向 对 当 前
          shell 发生作用，返回值是 0。如果发生重定向错误，返回状态是 1。
 
       exit [n]
          使得 shell 以状态值 n 退出。如果忽略了 n，退出状态是最后执行的命
          令的退出状态。在 shell 终止前，对 EXIT 的陷阱将被执行。
 
       export [-fn] [name[=word]] ...
       export -p
          给出的名称 names 被标记为自动地导出到后续执行的命令的环境中。 如
          果 给出了 -f 选项，名称 names 指的是函数。如果没有给出 names，或
          者如果给出了 -p 选项，将打印在这个 shell 中被导出的所有名字的 列
          表。选项 -n 使得以此为名的变量的导出属性被删除。 export 返回 0，
          除非遇到了非法的选项，name 之一不是有效的 shell 变量名，或者给出
          了 -f 选项，而 name 不是一个函数。
 
       fc [-e ename] [-nlr] [first] [last]
       fc -s [pat=rep] [cmd]
          命 令修复。第一种形式中，历史列表中从 first 到 last 范围内的命令
          都被选取。 First 和 last 可以指定为字符串 (可以定位最后一个以 此
          字符串开始的命令) 或者数字 (历史列表中的索引，负数被当作相对当前
          命令号的偏移)。如果没有指定 last，它在列举时被设为当前命令 (因此
          ‘‘fc  -l -10’’ 将输出最后 10 条命令)，其他情况下被设为 first。如
          果没有指定 first，它在编辑时被设为前一个命令，列举是设为 -16。
 
          选项 -n 使得列举时不显示命令号码。选项 -r 将命令顺序进行掉换。如
          果 给出了 -l 选项，命令将列举在标准输出上。否则，将启动 ename 给
          出的编辑器，编辑包含这些命令的文件。如果没有给出 ename，将使用变
          量 FCEDIT 的值，如果 FCEDIT 没有定义就使用 EDITOR 的值。如果仍然
          没有定义，将使用 vi。编辑结束后，被编辑的命令将回显并执行。
 
          第二种形式中，command 在每个 pat 的实例被 rep 替换后都被重新执行
          。使用这种特性时可以起一个有用的别名： ‘‘r=fc -s’’, 这样输入 ‘‘r
          cc’’ 将运行最后的以 ‘‘cc’’ 开头的命令，输入 ‘‘r’’ 将重新执行上一
          个命令。
 
          如 果 使用第一种形式，返回值是 0，除非遇到了非法的选项，或 first
          或 last 指定的历史行数超出了范围。如果给出了 -e 选项，返回值是最
          后执行的命令的返回值，或着是失败，如果临时文件中的命令执行出错。
          如果使用第二种形式，返回状态是重新执行的命令，除非 cmd 没有指 定
          一个有效的历史行，这种情况下 fc 返回失败。
 
       fg [jobspec]
          将 jobspec 恢复至前台，使它成为当前作业。如果 jobspec 不存在，将
          使用 shell 意义上的当前作业 current job。返回值是被放到前台的 命
          令的状态，或者是失败，如果在禁用作业控制时运行，或者在启用作业控
          制时运行，但 jobspec 没有指定有效的作业，或 jobspec 指定了没有使
          用作业控制的作业。
 
       getopts optstring name [args]
          getopts 由 shell 程序用来处理位置参数。 optstring 包含要识别的选
          项字符；如果某个字符跟随着冒号，那么这个选项需要一个参数，需要用
          空 白 和它隔离开。冒号和问号字符不能用作选项字符。每次它执行时，
          getopts 将下一个选项放在 shell 变量 name 中，如果 name 不存在 就
          初始化它；下一个要处理的参数的索引放在变量 OPTIND 中。每次 shell
          或 shell 脚本被执行的时候 OPTIND 被初始化为 1。当某个选项需要 参
          数 时， getopts 将那个参数放到变量 OPTARG 中。shell 不会自动重置
          OPTIND；在相同的 shell 中，如果要使用新的参数集合而需要多次调 用
          getopts 时，必须手动重置它。
 
          当 遇到选项结束的时候，getopts 以大于 0 的值退出。 OPTIND 被设置
          为第一个非选项的参数的索引，name 被设置为 ?。
 
          getopts 通常解释位置参数，但是如果 args 中给出 了 更 多 参 数 ，
          getopts 将解释它们。
 
          getopts  能以两种方式报告错误。如果 optstring 的第一个字符是冒号
          ，将使用 silent 安静的错误报告。通常的操作中，遇到非法选项或缺少
          选项的参数时将打印出诊断信息。如果变量 OPTERR 被设置为 0，不会显
          示错误消息，即使 optstring 的第一个字符不是冒号。
 
          如果发现了一个非法的选项， getopts 向 name 中置入 ?，并且如果 不
          是 安 静模式的话，打印错误消息并取消 OPTARG 的定义。如果 getopts
          是安静模式，找到的选项字符将置入 OPTARG，不会打印诊断消息。
 
          如果没有找到需要的参数，并且 getopts 不是安静模式，将向 name  置
          入一个问号 (?)，取消 OPTARG 的定义，打印出诊断消息。如果 getopts
          是安静模式，那么将向 name 置入一个冒号 (:) 并且 OPTARG 将设置 为
          找到的选项字符。
 
          getopts  返回真，如果找到了指定的/未被指定的选项。它返回假，如果
          遇到了选项结束或者发生了错误。
 
       hash [-lr] [-p filename] [-dt] [name]
          对于每个 name, 通过搜索 $PATH 中的目录，找到命令的全路径名并记录
          它。如果给出了 -p 选项，不会进行路径搜索，直接将 filename 作为命
          令的全路径名。选项 -r 使得 shell 忘记所有已记录的位置。选 项  -d
          使 得  shell  忘记已记录的 name 的位置。如果给出了 -t 选项，每个
          name 对应的全路径名被打印出来。如果给出多个 name 作为 -t 的参 数
          ，name  将在已记录的全路径名之前被打印出来。选项 -l 使得输出以一
          种可以重用为输入的格式显示。如果没有给出参数，或者只给出了 -l 选
          项，已记录的命令的信息将被打印出来。返回真，除非 name 没有找到或
          给出了非法的选项。
 
       help [-s] [pattern]
          显示关于内建命令的有用的信息。如果指定了 pattern (模式) ，  help
          给 出关于所有匹配 pattern 的命令的详细帮助；否则所有内建命令的帮
          助和 shell 控制结构将被打印出来。选项 -s 限制信息显示为简短的 用
          法概要。返回 0，除非没有匹配 pattern 的命令。
 
       history [n]
       history -c
       history -d offset
       history -anrw [filename]
       history -p arg [arg ...]
       history -s arg [arg ...]
          不 带选项的话，显示带行号的命令历史列表。列出的行中含有 * 的已经
          被修改过。参数 n 使得只显示最后 n 行。如果给出了 filename，它 被
          用做历史文件名；没有的话，将使用 HISTFILE 的值作为历史文件名。选
          项如果给出，则具有下列意义：
          -c     清空历史列表，删除所有条目。
          -d offset
             删除 offset 位置的历史条目。
          -a     将 ‘‘新’’ 的历史条目 (自当前 bash 会话开始输入的历史命令)
             追加到历史文件中。
          -n      将尚未从历史文件中读取的历史条目读入当前历史列表。这些行
             是当前 bash 会话开始之后，才追加到历史文件中的行。
          -r     读取历史文件的内容，使用它们作为当前历史。
          -w     将当前历史列表写入历史文件，覆盖历史文件的原有内容。
          -p     对后续的 args 进行历史替换，在标准输出上显示结果。不会 将
             结 果存入历史列表。每个 args 都必须被引用，来禁止普通的命
             令扩展。
          -s     将 args 保存到历史列表中，作为单独的条目。历史列表中的 最
             后一个命令在添加 args 之前被删除。
 
          返 回 0，除非遇到了非法的选项，读/写历史文件发生错误，在 -d 的参
          数中给出了无效的 offset，或者对 -p 的后续参数进行历史扩展失败。
 
       jobs [-lnprs] [ jobspec ... ]
       jobs -x command [ args ... ]
          第一种形式列出正在运行的作业。选项具有下列意义：
          -l     普通信息之外，列出进程ID。
          -p     只列出作业的进程组 leader 的进程ID。
          -n     只显示从上次用户得知它们的状态之后，状态发生改变的作业 的
             信息。
          -r     限制只输出正在运行的作业。
          -s     限制只输出停止的作业。
 
          如 果给出了 jobspec 输出被限制为仅此作业的信息。返回 0，除非遇到
          了非法的选项或给出了非法的 jobspec。
 
          如果给出了 -x 选项，作业 jobs 将 command 或 args 中的任 何  job-
          spec  替换为相应的进程组ID，执行 command，传递参数 args 给它并返
          回它的退出状态。
 
       kill [-s sigspec | -n signum | -sigspec] [pid | jobspec] ...
       kill -l [sigspec | exit_status]
          向以 pid 或 jobspec 为名的进程发送名为 sigspec 或 signum 的信 号
          。  sigspec 可以是一个信号名称，类似 SIGKILL 或信号编号； signum
          是一个信号编号。如果 sigspec 是一个信号名称，那么可以有，也可 以
          没有 SIG 前缀。如果没有给出 sigspec，那么假设是 SIGTERM。参数 -l
          将列出所有信号的名称。如果给出 -l 时还有任何参数，将列出参数对应
          的 信号名称，返回状态 0。 -l 的 exit_status 参数是一个数字，指定
          了一个信号编号或被信号终止的进程的退出状态值。 kill 返回真，如果
          至少成功发送了一个信号，或者返回假，如果发生了错误或遇到了非法的
          选项。
 
       let arg [arg ...]
          每个 arg 都是要求值的算术表达式 (参见 算术求值 (ARITHMETIC EVAL-
          UATION)  章节)。如果最后一个参数 arg 求值结果是 0， let 返回 1；
          否则返回 0。
 
       local [option] [name[=value] ...]
          对每个参数将创建一个名为 name 的局部变量并赋予值 value。    option
          可以是任何 declare 接受的值。当 local 用于函数内部时，它使得变量
          name 作用域局限于函数和它的子进程。没有操作数时， local 将局部变
          量 的列表写到标准输出。不在函数内部使用 local 会导致出错。返回 0
          ，除非在函数之外使用了 local，给出了非法的 name，或者 name 是 一
          个只读的变量。
 
       logout 退出登录 shell。
 
       popd [-n] [+n] [-n]
          从目录栈中删除条目。没有参数的话，从栈中删除顶层目录，执行 cd 切
          换到新的顶层目录。如果给出了参数，有下列的含义：
          +n     删除 dirs 给出的列表中从左数第 n 个条目 (从 0 算起)。例如
             ： ‘‘popd +0’’ 删除第一个目录， ‘‘popd +1’’ 第二个。
          -n     删除 dirs 给出的列表中从右数第 n 个条目 (从 0 算起)。例如
             ： ‘‘popd -0’’ 删除最后一个目录， ‘‘popd -1’’ 删除倒数 第
             二个。
          -n     阻止从栈中删除目录之后改变目录，这时只对栈进行操作。
 
          如 果命令 popd 成功，还要执行一个 dirs，返回 0。 popd 返回假，如
          果遇到了非法的选项，目录栈为空，指定了目录栈中不存在的条目，或者
          改变目录失败。
 
       printf format [arguments]
          在  format 控制下将格式化的 arguments 写到标准输出。 format 是一
          个字符串，包含三种类型的对象：普通字符，被简单地复制到标准输出，
          转义字符，被转换并复制到标准输出，格式说明，每一个都使得相邻的下
          一个 argument 被打印出来。在标准的 printf(1) 格式之外，%b   使 得
          printf  展开相应 arguments 中的反斜杠转义序列，%q 使得 printf 将
          相应的 argument 以一种可以重用为 shell 输入的格式输出。
 
          format 在需要时被重用，以处理所有的 arguments。如果 format 需 要
          比所提供的更多的 arguments，多出的格式说明视为已经提供了相应的 0
          值或空字符串。成功的话返回值是 0，失败则是非 0 值。
 
       pushd [-n] [dir]
       pushd [-n] [+n] [-n]
          将目录推入目录栈，或者轮换栈中的内容，使栈的顶部成为当前工作目录
          。没有参数时，交换顶部两个目录，返回 0，除非目录栈为空。如果给出
          了参数，它们有如下含义：
          +n     轮换栈中内容，使得 dirs 给出的列表中从左数第 n 个目录 (从
             0 数起) 成为目录栈的顶部。
          -n     轮换栈中内容，使得 dirs 给出的列表中从右数第 n 个目录 (从
             0 数起) 成为目录栈的顶部。
          -n     阻止向栈中添加目录之后改变目录，这时只对栈进行操作。
          dir    添加 dir 到栈顶，使得它成为新的当前工作目录。
 
          如果命令 pushd 成功，还要执行一个 dirs。如果使用第一 种 形 式 ，
          pushd   返 回 0，除非 cd 切换到目录 dir 失败。使用第二中形式时，
          pushd 返回 0，除非目录栈为空，指定了目录栈中不存在的元素，或者切
          换到指定的新的当前目录失败。
 
       pwd [-LP]
          打印当前工作目录的绝对路径名。如果给出了 -P 选项，或者设置了内建
          命令 set 的 -o physical 选项，打印出的路径名中不会包含符号链接。
          如果使用了 -L 选项，打印出的路径中可能包含符号链接。返回 0，除非
          在读取当前目录名时出错或给出了非法的选项。
 
       read [-ers] [-u fd] [-t timeout] [-a aname] [-p prompt] [-n nchars] [-d
       delim] [name ...]
          从标准输入读入一行，或从 -u 选项的参数中给出的文件描述符 fd 中读
          取，第一个词被赋予第一个 name, 第二个词被赋予第二个 name, 以此类
          推，多余的词和其间的分隔符被赋予最后一个 name.  如果从输入流读入
          的 词数比名称数少，剩余的名称被赋予空值。 IFS 中的字符被用来将行
          拆分成词。反斜杠字符 (\) 被用于删除读取的下一字符的特殊含义， 以
          及续行。如果给出了选项，将包含下列含义：
          -a aname
             词 被赋以数组变量 aname 的连续的下标，从 0 开始。在赋新值
             之前， aname 被取消定义。其他 name 参数被忽略。
          -d delim
             delim 的第一个字符被用于结束输入行，而不是新行符。
          -e     如果标准输入来自终端，将使用 readline (参见上面 的     READ-
             LINE 章节) 来获得输入行。
          -n nchars
             read 读入 nchars 个字符后返回，而不是等待一整行输入。
          -p prompt
             读取任何输入之前，在标准错误显示提示 prompt，末尾没有新行
             符。提示只有在输入来自终端时才会显示。
          -r     反斜杠不作为转义字符。反斜杠被认为行的一部分。特殊地， 一
             对反斜杠-新行符不作为续行。
          -s     安静模式。如果输入来自终端，字符将不会回显。
          -t timeout
             使得 read 超时并返回失败，如果在 timeout 秒内没有读入完整
             的一行输入。如果 read 不是从终端或管道读取输入，那么这 个
             选项无效。
          -u fd  从文件描述符 fd 中读取输入。
 
          如果没有给出 names，读取的一行将赋予变量 REPLY。返回值是 0，除非
          遇到了 EOF，readP 超时，或给出了非法的文件描述符作为 -u 的参数。
 
       readonly [-apf] [name ...]
          给 出的 name 将被标记为只读的； names 的值不能被后来的赋值语句改
          变。如果给出了 -f 选项，names 对应的函数也被标记。选项 -a 限制变
          量只能是数组类型。如果没有给出 name 参数，或者如果给出了 -p 选项
          ，将打印所有只读的名称。选项 -p 使得输出以一种可以被重新用作输入
          的 格式显示。返回值是 0，除非遇到了非法的选项， names 之一不是有
          效的 shell 变量名，或选项 -f 中给出的 name 不是一个函数。
 
       return [n]
          使得一个函数以指定值 n 退出。如果忽略了 n，返回状态是函数体中 执
          行 的 最后一个命令的退出状态。如果在函数外使用，但是是在一个以 .
          (source) 命令执行的脚本内，它使得 shell 中止执行脚本，返回 n  或
          脚本中执行的最后一个命令的退出状态。如果在函数外使用，并且不是在
          以 . 执行的脚本内，返回状态是假。
 
       set [--abefhkmnptuvxBCHP] [-o option] [arg ...]
          不带选项时，shell 变量的名称和值将以一种可以重用为输入的格式显示
          。输出根据当前语言环境进行排序。指定了选项的时候，它们设置或取消
          了 shell 的属性。处理完选项之后剩余的任何参数都被作为位置参数 的
          值 被赋值，分别赋予 $1, $2, ...  $n.  如果给出了选项，那么具有以
          下含义：
          -a      自动将被修改或创建的变量和函数标志为导出至后续命令的环境
              中。
          -b      后台作业结束时立即报告状态，而不是在下次显示主提示符前报
              告。只有在启用作业控制时才有效。
          -e      立即退出，如果 simple command (简单命令， 参 见 上 面 的
              SHELL GRAMMAR 语法) 以非零值退出。shell 不会退出，如果失
              败的命令是 until 或 while 循环的一部分， if 语句的一部分
              ， && 或 ││ 序列的一部分，或者命令的返回值是由 ! 翻转得
              到。针对 ERR 的陷阱，如果设置的话，将在 shell 退出前执行
              。
          -f      禁止路径扩展。
          -h      在查找并执行命令时，记住它们的位置。这是默认启用的。
          -k      所有以赋值语句形式出现的参数都被加入到命令执行的环境中，
              不仅是命令名前面那些。
          -m      监视模式。作业控制被启用。在支持这个选项的系统中，它在交
              互  shell   中是默认启用的 (参见上面的 JOB CONTROL 作业控
              制)。后台进程在单独的进程组中运行，结束时将打印出包含 它
              们退出状态的一行信息。
          -n       读取命令，但不执行。这可以用在检查 shell 脚本中的语法错
              误。交互 shell 中它被忽略。
          -o option-name
              option-name 可以是如下之一：
              allexport
                  与 -a 相同。
              braceexpand
                  与 -B 相同。
              emacs   使用 emacs 样式的命令行编辑界面。这个选项在交 互
                  shell 中默认启用，除非 shell 以 --noediting 选项
                  启动。
              errexit 与 -e 相同。
              hashall 与 -h 相同。
              histexpand
                  与 -H 相同。
              history 允许记录命令历史，如上述 HISTORY 中的描述。这 个
                  选项在交互 shell 中默认启用。
              ignoreeof
                  它 的 效 果 是 好 像 已 经 执 行 了  shell  命令
                  ‘‘IGNOREEOF=10’’ 一样 (参见上面 的  Shell     Vari-
                  ables 变量)。
              keyword 与 -k 相同。
              monitor 与 -m 相同。
              noclobber
                  与 -C 相同。
              noexec  与 -n 相同。
              noglob  与 -f 相同。 nolog 当前被忽略。
              notify  与 -b 相同。
              nounset 与 -u 相同。
              onecmd  与 -t 相同。
              physical
                  与 -P 相同。
              posix    如果默认操作与 POSIX 1003.2 不同的话，改变 bash
                  的行为，来满足标准 (posix mode)。
              privileged
                  与 -p 相同。
              verbose 与 -v 相同。
              vi      使用 vi 样式的命令行编辑界面。
              xtrace  与 -x 相同。
              如果给出了不带 option-name 的 -o 选项，当前选项的值将 被
              打 印出来。如果给出了不带 option-name 的 +o 选项，将在标
              准输出显示一系列可以重建当前选项设定的 set 命令。
          -p      打开 privileged mode (特权模式)。在这个模式中，不会处 理
              $ENV 和 $BASH_ENV 文件，shell 函数不会从环境中继承，环境
              中如果有变量 SHELLOPTS，也将被忽略。如果 shell 启动时 的
              有 效用户(组) ID 与真实用户(组) ID 不同，并且没有给出 -p
              选项，将执行这些操作，有效用户 ID 将设置为真实用户 ID 。
              如果启动是给出了 -p 选项，有效用户 ID 不会被重置。将这个
              选项关闭使得有效用户和组 ID 被设置为真实用户和组 ID。
          -t      读取并执行一个命令之后退出。
          -u      在进行参数扩展时，将未定义的变量作为错误。如果试图扩展未
              定 义 的 变 量，shell 将输出一条错误消息; 如果是非交互的
              shell，shell 将以非零值退出。
          -v      在读取输入的同时打印出来。
          -x      扩展每个简单命令之后，显示 PS4 的值，接着显示命令和它 扩
              展后的参数。
          -B      shell  执行花括号扩展 (参见上面的 Brace Expansion)。这是
              默认允许的。
          -C      如果设置的话， bash 使用重定向操作符 >, >&, 和 <> 时，不
              会 覆盖已存在的文件。可以使用重定向操作符 >| 代替 > 来创
              建输出文件，从而绕过这个限制。
          -H      允许 Enable !  样式的历史替换。在交互 shell 中这个选项是
              默认启用的。
          -P      如果设置的话，shell 在执行类似 cd 的，改变当前工作目录的
              命令时，不会跟随符号连接。它将使用物理的目录结构来代替。
              默认情况下， bash 在执行改变当前目录的命令时跟随路径的逻
              辑链。
          --      如果这个选项没有参数，将取消位置参数的定义。否则，位置参
              数将设置为 arg，即使它们以 - 开始。
          -       通 知 信号的结束，使得所有剩余的 arg 被赋予位置参数。 -x
              和 -v 选项被关闭。如果没有 arg，位置参数将不会改变。
 
          这个选项默认是关闭的，除非另外说明。使用 + 而不是 - 使得这些选项
          被 关闭。选项都可以作为参数，在 shell 启动时指定。当前的选项集合
          可以从 $- 找到。返回值总是真，除非遇到了非法的选项。
 
       shift [n]
          从 n+1 ... 开始的选项被重命名为 $1 ....  从 $# 向下直 到  $#-n+1
          的 选项被取消定义。 n 必须是非负整数，小于或等于 $#。如果 n 是 0
          ，不会改变参数。如果没有给出 n，就假定它是 1。如果 n 比 $# 大 ，
          位 置参数不会改变。返回值大于 0，如果 n 比 $# 大或小于 0；否则返
          回 0。
 
       shopt [-pqsu] [-o] [optname ...]
          对于控制可选的 shell 行为的变量，改变它们的值。没有选项或者有 -p
          选项时，将显示所有可设置的选项列表，以及它们是否已经设置的指示。
          -p 使得输出以一种可以被重用为输入的形式显示。其他选项有如下含 义
          ：
          -s     允许(设置) 每个 optname。
          -u     禁止(取消) 每个 optname。
          -q      禁止通常的输出 (安静模式)；返回状态指示了 optname 是否被
             设置。如果对 -q 给出了多个 optname 参数，如果所有 optname
             都被允许，返回值就是 0；否则返回非零值。
          -o     限制 optname 的值为内建命令 set 的 -o 选项定义的值。
 
          如 果使用 -s 或 -u 时没有给出 optname 参数，显示将分别限于被设置
          或被取消的选项。除非另外说明，shopt 选项默认被禁止(取消)。
 
          返回值在列出选项时是 0，如果所有 optname 都被允许的话，否则是 非
          零 值 。 当 设 置或取消选项时，返回值是 0，除非 optname 是非法的
          shell 选项。
 
          shopt 选项的列表是：
 
          cdable_vars
              如果设置的话，内建命令 cd 的参数如果不是目录，就假定是一
              个变量，它的值是要切换到的目录名。
          cdspell 如果设置的话， cd 命令中目录的细微拼写错误能够得以纠正。
              检查的错误包括字符错位，缺字符，重复输入同一字符。如果找
              到了正确的值，将打印正确的文件名，命令将继续。这个选项只
              能在交互 shell 中使用。
          checkhash
              如果设置的话，bash 在执行命令前检测散列表中的命令是否 存
              在。如果一个被散列的命令不再存在，将进行正常的路径搜索。
          checkwinsize
              如果设置的话，bash 在每条命令执行后检测窗口大小，如果 需
              要的话就更新 LINES 和 COLUMNS 的值。
          cmdhist 如果设置的话， bash 试着将一个多行命令的所有行放到同一个
              历史条目中。这样使得多行命令可以容易地重新修改。
          dotglob 如果设置的话， bash 会把以 ‘.’ 开始的文件名包含在路径 名
              扩展的结果中。
          execfail
              如 果设置的话，非交互的 shell 如果不能执行作为参数提供给
              内建命令 exec 的文件时将不会退出。交互的 shell  在  exec
              失败时不会退出。
          expand_aliases
              如 果设置的话，别名被扩展，就像上面 ALIASES 中讲到的一样
              。这个选项在交互 shell 中是默认启用的。
          extglob 如果设置的话，将允许上面 Pathname Expansion 中提到的扩展
              模式匹配特性。
          histappend
              如 果设置的话，在 shell 退出时，历史列表将追加到以 HIST-
              FILE 的值为名的文件之后，而不是覆盖文件。
          histreedit
              如果设置的话，并且正在使用 readline，用户可以重新修改 失
              败的历史替换。
          histverify
              如 果设置的话，并且正在使用 readline，历史替换的结果不会
              立即传给 shell 解释器。结果行被加载到 readline 编辑缓 冲
              区，允许进行进一步的修改。
          hostcomplete
              如 果设置的话，并且正在使用 readline， bash 将试着对正在
              进行补全的包含  的词进行主机名补全 (参见上面的  READLINE
              中的 Completing 段落)。这是默认允许的。
          huponexit
              如 果设置的话，在交互的登录 shell 退出时 bash 将向所有作
              业发出 SIGHUP 信号。
          interactive_comments
              如果设置的话，将允许在交互 shell 中遇到以 # 开头的词时忽
              略 这 个词和一行中所有剩余的字符 (参见上面的 COMMENTS 注
              释)。这个选项是默认允许的。
          lithist 如果设置的话，并且允许了 cmdhist 选项，多行的命令在保 存
              到历史中时将包含新行符，而不是在可能的地方使用分号。
          login_shell
              如果 shell 作为登录 shell 启动，将设置这个选项 (参见上面
              的 启动(INVOCATION) )。这个值不可修改。
          mailwarn
              如果设置的话，并且 bash 正在检测上次检测以来被存取过的邮
              件 ，将显示 ‘‘The mail in mailfile has been read’’(mail-
              file 中的邮件已被读取)。
          no_empty_cmd_completion
              如果设置的话，并且正在使用 readline，试图在空行上执行 补
              全时， bash 不会搜索 PATH 来查找可能的补全。
          nocaseglob
              如果设置的话， bash 进行路径扩展时使用大小写不敏感方式匹
              配文件名(参见上面的 Pathname Expansion 路径扩展)。
          nullglob
              如果设置的话， bash 将允许不匹配任何文件的模式扩展为空字
              符 串而不是它们自身(参见上面的 Pathname Expansion 路径扩
              展)。
          progcomp
              如果设置的话，将启用可编程补全功能 (参 见 上 面 的  Pro-
              grammable Completion)。这个选项是默认启用的。
          promptvars
              如 果设置的话，提示字符串要经过上面 PROMPTING 中描述的扩
              展，然后还要经过变量和参数扩展。这个选项是默认启用的。
          restricted_shell
              shell 设置这个选项，如果它是以受限模式启用的 (参见下面的
              受 限的shell(RESTRICTED SHELL) 章节)。这个值不能修改。在
              执行启动文件时，它不会被重置，使得启动文件可以得知 shell
              是否是受限的。
          shift_verbose
              如 果设置的话，内建命令 shift 在偏移量超过位置参数的个数
              时打印一条错误消息。
          sourcepath
              如果设置的话，内建命令 source (.) 使用 PATH 中的值来查找
              包含作为参数给出的文件。这个选项默认是启用的。
          xpg_echo
              如果设置的话，内建命令 echo 默认扩展反斜杠转义序列。
       suspend [-f]
          挂起 shell 的执行，直到收到一个 SIGCONT 信号。选项 -f 表示如果这
          是一个登录 shell，那么不要提示，直接挂起。返回值是 0，除非 shell
          是登录 shell 并且没有指定 -f，或者没有启用作业控制。
       test expr
       [ expr ]
          返 回状态值 0 或 1，根据条件表达式 expr 的求值而定。每个操作符和
          操作数都必须是一个单独的参数。表达式使用上面 条件表达式  (CONDI-
          TIONAL EXPRESSIONS) 中的操作构造。
 
          表达式可以用下列操作符结合，以优先级的降序列出。
          ! expr 值为真，如果 expr 为假。
          ( expr )
             返回 expr 的值。括号可以用来超越操作符的一般优先级。
          expr1 -a expr2
             值为真，如果 expr1 和 expr2 都为真。
          expr1 -o expr2
             值为真，如果 expr1 或 expr2 为真。
 
          test 和 [ 使用基于参数个数的一系列规则，对条件表达式进行求值。
 
          0 arguments
             表达式为假。
          1 argument
             表达式为真，当且仅当参数非空。
          2 arguments
             如 果第一个参数是 !，表达式为真，当且仅当第二个参数为空。
             如果第一个参数是上面 条件表达式 (CONDITIONAL EXPRESSIONS)
             中 列出的单目条件运算符之一，表达式为真，当且仅当单目测试
             为真。如果第一个参数不是合法的单目条件运算符，表达式为 假
             。
          3 arguments
             如果第二个参数是上面 条件表达式 (CONDITIONAL EXPRESSIONS)
             中列出的二进制条件操作符之一，表达式的结果是使用第一和 第
             三 个参数作为操作数的二进制测试的结果。如果第一个参数是 !
             ，表达式值是使用第二和第三个参数进行双参数测试的结果取 反
             。 如果第一个参数是 (，第三个参数是 )，结果是对第二个参数
             进行单参数测试的结果。否则，表达式为假。这种情况下 -a  和
             -o 操作符被认为二进制操作符。
          4 arguments
             如 果第一个参数是 !，结果是由剩余参数组成的三参数表达式结
             果取反。否则，表达式被根据上面列出的优先级规则解释并执 行
             。
          5 或更多 arguments
             表达式被根据上面列出的优先级规则解释并执行。
 
       times  对 shell 以及 shell 运行的进程，打印累计的用户和系统时间。返回状
          态是 0。
 
       trap [-lp] [arg] [sigspec ...]
          当 shell 收到信号 sigspec 时，命令 arg 将被读取并执行。如果没 有
          给 出 arg 或者给出的是 -, 所有指定的信号被设置为它们的初始值 (进
          入 shell 时它们的值)。如果 arg 是空字符串， sigspec 指定的信号被
          shell  和它启动的命令忽略。如果 arg 不存在，并且给出了 -p 那么与
          每个 sigspec 相关联的陷阱命令将被显示出来。如果没有给出任何参 数
          ， 或只给出了 -p， trap 将打印出与每个信号编号相关的命令列表。每
          个 sigspec 可以是 <signal.h> 定义的信号名，或是一个信号编号。 如
          果  sigspec   是    EXIT (0)，命令 arg 将在 shell 退出时执行。如果
          sigspec 是 DEBUG, 命令 arg 将在每个简单命令 (simple command， 参
          见 上面的 SHELL GRAMMAR) 之后执行。如果 sigspec 是 ERR, 命令 arg
          将在任何命令以非零值退出时执行。如果失败的命令是 until 或   while
          循环的一部分， if 语句的一部分， && 或 ││ 序列的一部分，或者命令
          的返回值是通过 ! 转化而来， ERR 陷阱将不会执行。选项 -l  使 得
          shell  打印信号名和对应编号的列表。 shell 忽略的信号不能被捕捉或
          重置。在子进程中，被捕捉的信号在进程创建时被重置为初始值。返回值
          为假，如果 sigspec 非法；否则 trap 返回真。
 
       type [-aftpP] name [name ...]
          没有选项时，指示每个 name 将如何被解释，如果用作一个命令名。如果
          使用了 -t 选项， type 打印一个字符串，内容是如下之 一 ：    alias,
          keyword,  function,  builtin, 或 file ，如果 name 分别是一个别名
          ，shell 保留字，函数，内建命令或磁盘文件。如果没有找到 name， 那
          么不会打印任何东西，返回退出状态假。如果使用了 -p 选项， type 返
          回如果 name 作为命令名，将被执行的磁盘文件名；或者返回空， 如 果
          ‘‘type  -t name’’ 不会返回 file.  选项 -P 选项强制对每个 name 搜
          索 PATH，即使 ‘‘type -t name’’ 不会返回 file.  如果命令在散列 中
          ， -p 和 -P 将打印散列的值，而不是 PATH 中首先出现的那一个文件。
          如果使用了 -a 选项， type 打印所有包含可执行的名称 name 的场合。
          结果包括别名和函数，当且仅当没有同时使用 -p 选项。使用 -a 时不会
          查找散列中的命令表。选项 -f 阻止 shell 进行查找，就像在内建命 令
          command 中一样。 type 返回真，如果找到了任何参数。什么都没找到则
          返回假。
 
       ulimit [-SHacdflmnpstuv [limit]]
          在支持它的系统上，对 shell 和它启动的进程，提供对可用资源的控 制
          。选项 -H 和 -S 指定为所给资源设定的硬性和柔性限额。硬性限额在设
          置后不能增加；柔性限额可以增加，直到与硬性限额相等。如果没有给出
          -H 或 -S 选项，将同时设置硬性和柔性限额。 limit 的值可以是一个数
          字，单位是指定资源的单元值，或者是特殊值 hard, soft,  或   unlim-
          ited  之一，意思分别是当前硬性限额，当前柔性限额和没有限额。如果
          忽略了 limit，将打印出当前对资源的柔性限额值，除非给出了 -H 选项
          。当指定多于一个资源时，限额名称和单位将在值之前打印出来。其他选
          项按照如下意义解释：
          -a     报告所有当前限额
          -c     core 文件的最大值
          -d     进程数据段的最大值
          -f     shell 创建的文件的最大值
          -l     内存中可以锁定的最大值
          -m     常驻内存的最大值
          -n     打开的文件描述符最大个数 (大多数系统不允许设置这个值)
          -p     管道大小，以 512 字节的块为单位 (这个值可能不能设置)
          -s     栈的最大值
          -t     cpu 时间总数的最大值，以秒计
          -u     用户可以运行的最大进程数
          -v     shell 可用的虚拟内存总量的最大值
 
          如果给出了 limit，它将是指定资源的新限额 (选项 -a 只显示它们) 。
          如果没有给出选项，则假设有 -f。值的递增间隔是 1024 字节，除了 -t
          单位是 秒， -p 单位是 512 字节的块个数， -n 和 -u 是不可调节的值
          。返回 0，除非给出了非法的选项或参数，或者在设置新的限额时发生了
          错误。
 
       umask [-p] [-S] [mode]
          用户创建文件的掩码被设置为 mode.   如果 mode 以数字开始，它被解释
          为一个八进制数；否则被解释为类似于 chmod(1) 接受的符号形式的模式
          掩码。如果忽略了 mode，将打印当前掩码值。选项 -S 使得掩码以符 号
          形 式 打 印 ；默认输出是八进制数。如果给出了 -p 选项，并且忽略了
          mode，输出将是一种可以重用为输入的形式。返回值是 0，如果成功改变
          了模式，或者没有给出 mode。其他情况返回假。
 
       unalias [-a] [name ...]
          从 已定义的别名列表中删除 name。如果给出了 -a 将删除所有别名定义
          。返回值是真，除非给出的 name 不是已定义的别名。
 
       unset [-fv] [name ...]
          将每个 name 对应的变量或函数删除。如果没有给出选项，或者给 出 了
          -v 选项， name 仅包括 shell 变量。只读的变量不能被取消定义。如果
          给出了 -f 选项， name 仅包括 shell 函数，函数的定义将被删除。 每
          个被取消定义的变量或函数都被从后续命令的环境中删除。如果 RANDOM,
          SECONDS, LINENO, HISTCMD, FUNCNAME, GROUPS, 或者 DIRSTACK 中的任
          何一个被取消定义，它们将丧失特殊的属性，即使它们后来被重新定义。
          退出状态是真，除非 name 不存在或是只读的。
 
       wait [n]
          等待指定的进程，返回它的终止状态。 n 可以是进程 ID 或一个作业 号
          ；如果给出的是作业号，将等待作业的管道中所有进程。如果没有给出 n
          ，将等待所有当前处于激活状态的子进程，返回状态是 0。如果 n 指 定
          了不存在的进程或作业，返回状态是 127。否则，返回状态是所等待的最
          后一个进程或作业的退出状态。