# 1.命令执行(COMMAND EXECUTION)
 命令被拆分为词之后，如果结果是一个简单命令和可选的参数列表，将执行下面的操作。

* 如果命令名中没有斜杠，shell 试图定位命令位置。如果存在同名的 shell 函数， 函 数 将 被执行，像上面 FUNCTIONS 中讲到的一样。如果名称不是一个函数，shell 从 内建命令中搜索它。如果找到对应命令，它将被执行。
* 如果名称既不是 shell 函数也不是一个内建命令，并且没有包含斜杠， bash 搜索  PATH 的每个成员，查找含有此文件名 (可执行文件) 的目录。 Bash 使用散列表来储存可执行文件的全路径 (参见下面的 shell 内建命 令(SHELL  BUILTIN COMMANDS) 中的 hash。只有在散列表中没有找到此命令，才对 PATH 进行完整的搜索。如果搜索不成功，shell 输出错误消息，**返回退出状态 127**。
*  如果搜索成功，或者命令中包含一个或多个斜杠，shell 在单独的执行环境中 执行这个程序。参数 0 被设置为所给名称；命令的其他参数被设置为所给的参数，如果有的话。
*  如果执行失败，因为文件不是可执行格式，并且此文件不是目录，就假定它是 一个  shell  script (脚本)，一个包含 shell 命令的文件。此时将孵化 (spawn)出一个子 shell 来执行它。子 shell 重新初始化自身，效果就好像是执行了 一个 新的 shell 来处理脚本一样，但是父 shell 保存的命令位置仍然被保留 (参见下面的 shell 内建命令(SHELL BUILTIN COMMANDS) 中的 hash)。
*  如果程序是以`#!`开头的文件，那么第一行的其余部分指定了这个程序的解释器。 shell 执行指定的解释器，如果操作系统不会自行处理这种可执行文件格式的话。解释器的参数由下面三部分组成：程序第一行中解释器名称之后的可选的 一个参数，程序的名称，命令行参数，如果有的话。

# 2.命令执行环境(COMMAND EXECUTION ENVIRONMENT)

shell 有 execution environment (执行环境) 的概念，由下列内容组成：

* shell启动时**继承的打开的文件**，例如在内建命令exec中使用重定向修改的结果
* 当前工作目录，使用 cd，pushd 或者 popd 设置，或是由 shell 在启动时继承得到
* 文件创建模式掩码，使用 umask 设置或是从 shell 的父进程中继承得到
* 当前陷阱，用 trap 设置
* shell 参数，使用变量赋值或者 set 设置，或者是从父进程的环境中继承得到
* shell 函数，在执行中定义或者是从父进程的环境中继承得到
* 设为允许的选项，在执行时设置 (要么是默认允许的，要么是命令行给出的) 或者是用 set 设置
* 用 shopt 设为允许的选项
* 用 alias 定义的 shell 别名
* 各种进程号，包含后台作业的进程号，`$$`的值，以及`$PPID`的值

当并非 shell 函数或内置命令的简单命令执行时，它在一个由下述内容组成的单独的执行环境中启动。除非另外说明，值都是从 shell 中继承的。

* shell 打开的文件，加上对命令使用重定向修改和添加的文件
* 当前工作目录
* 文件创建模式掩码
* 标记为导出 (export) 的 shell 变量，以及传递到环境中为这个命令导出的变量
*  shell 捕捉的陷阱被重置为从 shell 的父进程中继承的值，shell 忽略的陷阱也被忽略

在**单独的环境中启动的命令不能影响** shell 的执行环境。

命令替换和异步命令都在子 shell 环境中执行。子 shell 环境是原有 shell 环境的赋值，但 shell 捕捉的陷阱被重置为 shell 启动时从父进程中继承的值 。作 为 管道一部分来执行的内建命令也在一个子 shell 环境中执行。对子 shell环境所作修改不能影响到原有 shell 的执行环境。

如果命令后面是 & 并且没有启用作业控制，命令的默认标准输入将是空文件`/dev/null` 。否则，被执行的命令从调用它的 shell 中继承被重定向修改的文件描述符。

# 3.环境(ENVIRONMENT)
当一个程序执行时，它被赋予一个字符串数组，成为环境 environment。它是 一个名称-值对 (`name-value`) 的列表，形式是 name=value.

* shell  提供了多种操作环境的方法。启动时，shell 扫描自身的环境，为每个找到的名字创建一个参数，自动地将它标记为 export (向子进程导出的)。
* 被执行的命令继承了这个环境。
* export 和`declare -x`命令允许参数和函数被加入到环境中或从环境中删除。
* 如果环境中参数的值被修改，新值成为环境的一部分 ，替换了旧值。所有被执行的命令继承的环境包含 shell 的初始环境 (可能值被修改过)，减去被 unset 命令删除的，加上通过 export 和 declare -x 命令添 加的部分。

可 以在任何 simple command 或函数的环境中设定暂时有效的参数，只要将参数赋值放在命令前面就可以了，参见上面 PARAMETERS 的描述。这些赋值语句只在这个命令的环境中有效。

如 果设置了内建命令 set 的 -k 选项， 所有的变量赋值都将放到命令的环境中，不仅是在命令名前面的那些。

当 bash 执行一个外部命令时，变量`_`被设置为命令的文件全名，然后被传递到命令的环境之中。

# 4.退出状态("EXIT STATUS")
从 shell 的角度看，一个命令退出状态是 0 意味着成功退出。退出状态是 0 表明成功。非零状态值表明失败。当命令收到 fatal signal N 退出时，bash 使用`128+N`作为它的退出状态。

如 果没有找到命令，为执行它而创建的子进程返回`127`。如果找到了命令但是文件不可执行，返回状态是`126`。

如果命令由于扩展或重定向错误而失败，退出状态大于零。
shell 内建命令如果成功返回 0(true)，执行时出错则返回非零 (false)。所有内建命令返回 2 来指示不正确的用法。

Bash 自身返回最后执行的命令的退出状态，除非发生了语法错误，这时它返回非零值。参见下面的内建命令 exit。