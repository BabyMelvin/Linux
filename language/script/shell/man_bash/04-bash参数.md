# 参数(PARAMETERS)

一个参数 parameter 是一个储存值的实体。它可以是一个名称 name, 一个数 字或 者 是 下 面  Special Parameters 特殊参数章节中列出的特殊字符之一。从shell 的角度来看，一个变量 variable 是一个由名称 name 代表的参数。一 个变 量 有**一个值 value **以及**零个或多个属性 attibutes**。属性可以使用内建命令`declare`来设置(参见下面 shell 内建命令(SHELL BUILTIN COMMANDS) 章节中对`declare`的描述)。

 如果给一个参数赋值，那么它就被定义了。空字符串是有效的值。一旦一个变量被定义了，它只能用内建命令 `unset`来取消(参见下面 shell 内建 命 令(SHELLBUILTIN COMMANDS) 章节).

 一个变量 variable 可以用这样的语句形式来赋值：`name=[value]`

* 如 果没有给出值 value，变量就被赋为空字符串。
* 所有值 values 都经过了波浪线扩展，参数和变量扩展，命令替换，算术扩展和引用的删 除(参见下面 EXPANSION 扩展章节)。
  * 如果变量设置了integer整数属性，那么值 value 将进行算术扩展，即使没有应用`$((...))`扩展 (参见下面的 Arithmetic Expansion算术扩展章节)。不会进行词的拆分，除非是下面 Special Parameters 特殊参数中提到的 "`$@`"。
  * 不会进行路径的扩展。赋值语句也出现在下列内建命令中，作为它们的参数：`declare`, `typeset`, `export`, `readonly`, 和 `local`。

# 1.Positional Parameters 位置参数
位置参数 positional parameter 是以一或多个数字代表的参数，除了 0。位置参数是在 shell 启动时，根据它的参数来赋值的，也可以用内建命令`set`来重新赋值。位置参数不能用赋值语句来赋值。在一个 shell 函数被执行的时候，位置参数会被暂时地替换掉 (参见下面的 FUNCTIONS 函数章节)。

 当位置参数由两个以上的数字构成时，它必须放在**括号内** (参见下面的EXPANSION 扩展章节)。

 # 2.Special Parameters 特殊参数

shell 对一些参数做特殊处理。这些参数只能被**引用而不能被赋值**。

* `*`:扩展为位置参数，**从1开始**。如果扩展发生在双引号中，它扩展为一个词，值是各个参数，以特殊变量 `IFS`的**第一个字符分隔** 。 也 就 是 说，"$*"  等价于`"$1c$2c..."`，这里c是变量`IFS`的第一个字符。如果没有设置 IFS，那么参数将用空格分隔。
* `@`:扩展为位置参数，**从 1 开始**。如果扩展发生在双引号中，**每个参数都将扩展为一个词**。也就是说， `"$@"` 等价于`"$1" "$2" ... `如果位置参数不存在，`"$@"` 和 `$@` 扩展为空 (即，它们被删除了)。
* `#`:扩展为位置参数的个数，以十进制表示。
* `?`:扩展为最近执行的前台管道的状态。
* `-`:扩展为当前选项标志。标志是在启动时或以内建命令set指定的，或者是shell自身设置的(例如选项-i)。
* `$`:扩展为shell的进程ID。在一个 `() 子shell`中，它扩展为**当前shell的进程ID而不是子shell** 的。
* `!`:扩展为最近一次执行的后台 (异步) 命令的进程号。
* `0`:扩展为 shell 或者 shell 脚本的名称。这个变量是在 shell 初始化 时设置的。如果 bash 是执行脚本文件时启动的， `$0`将设置为那个文件的名称。如果 bash 启动时的参数包含 `-c`，那么 `$0 `被设置为启动命令行被执行后的第一个参数，如果有的话。否则，它被设置为用来启动 bash的文件名，就是参数 0.
* `_`:shell 启动时，设置为shell或参数中被**执行的shell脚本的绝对路径名**。然后，在扩展时扩展为上一个命令的最后一个参数。它也被设置为被执行的每个命令的文件全名并且被设置到这个命令执行的环境当中。当检查邮件时，这个参数保存着正在检查的邮件文件的名称。

# 3.Shell Variables 变量
shell 定义了下列变量：

* `BASH`:扩展为用来启动当前bash实例的文件全名。使用bash:`/bin/bash`
* `BASH_VERSINFO`:一个只读数组变量，成员保存着当前 bash 实例的版本信息。赋予数组元素的值是如下这些：
  * BASH_VERSINFO[0]        主版本号 (release).
  * BASH_VERSINFO[1]        次版本号 (version).
  * BASH_VERSINFO[2]        补丁版本
  * BASH_VERSINFO[3]        编译信息
  * BASH_VERSINFO[4]        发布时的状态 (例如, beta1).
  * BASH_VERSINFO[5]        MACHTYPE 平台类型
* BASH_VERSION:扩展为一个字符串，描述了这个 bash.  实例的版本。`4.3.11(1)-release`
* `COMP_CWORD`:`${COMP_WORDS}`的索引，指向当前光标位置所在的词。这个变量只有在被可编程补全功能 (参见下面的 Programmable Completion章节) 调用的shell函数中才可用。
* `COMP_LINE`:相对于当前命令起始处的当前光标位置。如果当前光标位置是当前命令的末端，它的值就和`${#COMP_LINE}`相等。这个变量只有在被命令补全功能调用的 shell 函数和外部命令中才可用。
* `COMP_WORDS`: 一个数组变量 (参见下面的 Arrays(数组)一节)，由当前命令行的各个单词构成。这个变量只有在被命令补全功能调用的 shell 函数中才可用。
* `DIRSTACK`:一个数组变量，包含当前目录栈的内容。栈中的目录排列的顺序就是用内建命令 dirs 显示时的顺序。对这个数组变量的成员赋值可以用来修改栈中已有的目录，但是要添加和删除目录就必须使用内建命令pushd和popd。对它赋值不会改变当前目录。如果取消了 DIRSTACK 的定义，它就失去了它的特殊意义，即使后来重新定义它。
* `EUID`扩展为当前用户的有效用户 ID。它在 shell 启动时设置。它是只读的
* `FUNCNAME`:当前执行的 shell 函数名。这个变量只有在执行一个 shell 函数时存在。向 FUNCNAME 赋值没有效果并且返回一个错误。如果取消了  FUNCNAME的定义，它就失去了特殊的意义，即使后来重新定义它。
* `GROUPS`:一个数组变量，包含当前用户所属的组的列表。向 GROUPS 赋值没有效果并且返回一个错误。如果取消了 GROUPS 的定义，它就失去了特殊的意义，即使后来重新定义它。
* `HISTCMD`:当前命令的历史编号，或者历史列表中的索引。如果取消了HISTCMD的定义，它就失去了特殊的意义，即使后来重新定义它。
* `HOSTNAME`:自动设置为当前的主机名。
* `HOSTTYPE`:自动设置为一个字符串，唯一地标识着正在运行 bash 的机器类型。默认值是系统相关的。
* `LINENO`:每次引用这个参数时，shell 将它替换为一个指示在脚本或函数中当前行号的十进制数字(从 1 开始)。如果不是在脚本或函数中，替换得到的 值不一定有意义。如果取消了 LINENO 的定义，它就失去了特殊的意义，即使后来重新定义它。
* `MACHTYPE`:自动设置为一个字符串，完整的描述了正在运行 bash 的系统类型，格式是标准的 GNU cpu-company-system 格式。默认值是系统相关的。
* `OLDPWD` 上一次命令 cd 设置的工作目录。
* `OPTARG` 内建命令`getopts`处理的最后一个选项参数值 (参见下面的 shell 内建命令(SHELL BUILTIN COMMANDS) 章节)。
* `OPTIND` 内建命令 `getopts` 将处理的下一个参数的索引 (参见下面的 shell 内建命令(SHELL BUILTIN COMMANDS) 章节)。
* `OSTYPE` 自动设置的一个字符串，描述了正在运行 bash 的操作系统。默认值是系统相关的。
* `PIPESTATUS`:一个数组变量 (参见下面的 Arrays 数组章节)，包含最近执行的前台 管道中的进程(可能只包含一个命令)的退出状态。
* `PPID`:shell 的父进程的进程号。这个变量是只读的。
* `PWD`:由cd命令设置的当前工作目录。
* `RANDOM`:每次引用这个参数时，都会产生一个`0`到`32767`之间的随机整数。可以通过向RANDOM赋值来初始化随机数序列。如果取消了 RANDOM 的定义，它就失去了特殊的意义，即使后来重新定义它。
* `REPLY`:变量的值将作为内建命令 read 的输入，如果命令没有参数的话。
* `SECONDS`:每次引用这个参数时，返回 shell 自运行以来的秒数。如果向SECONDS赋值，此后对它的引用将返回自赋值时起的秒数加上所赋予的值。如果取消 SECONDS 的定义，它就失去了特殊的意义，即使后来重新定义它。
* `SHELLOPTS`:一个**冒号分隔**的被允许的shell选项列表。列表中每个词都是内置命令`set`的`-o`选项的有效参数。 `SHELLOPTS`中出现的选项也是`set -o`显示为 on 的选项。如果 bash 启动时从环境中找到这个变量，那么在读取任何配置文件之前，列表中的每个选项都将被设置。这个变量是只读的。
* `SHLVL`  每次启动一个 bash 的实例时都会增加。
* `UID`    扩展为当前用户的 ID，在启动时初始化。这个变量是只读的。
 

下列变量被shell使用。有时bash会为变量赋默认值；这些情况在下面会标出。
 
* `BASH_ENV`:如果 bash 在执行一个 shell 脚本时设定了这个变量，它的值将被解 释为一个文件名，包含着初始化 shell 用到的命令，就像 `~/.bashrc` 中一样。 BASH_ENV 的值在被解释为一个文件名之前要经过参数扩展，命令替换和算术扩展。不会使用 PATH 来查找结果文件名。
* `CDPATH` 命 令 cd 的搜索路径。这是一个冒号分隔的目录列表，shell 从中查找cd 命令的目标目录。可以是这样： "`.:~:/usr`".
* `COLUMNS`用在内建命令 select 当中，用来判断输出选择列表时的**终端宽度**。自动根据**SIGWINCH信号**来设置。
* `COMPREPLY`:一 个数组变量，bash 从中读取可能的命令补全。它是由命令补全功能调用的 shell 函数产生的。
* `FCEDIT`内建命令 fc 默认的编辑器。
* `FIGNORE`:一个冒号分隔的后缀名列表，在进行文件名补全时被忽略 (参见下面的READLINE章节)。一个后缀满足其中之一的文件名被排除在匹配的文件名之外。可以是这样： "`.o:~`".
* `GLOBIGNORE`:一个冒号分隔的模式列表，定义了路径名扩展时要忽略的文件名集合。如果一个文件名与路径扩展模式匹配，同时匹配 GLOBIGNORE 中的一个模式时，它被从匹配列表中删除。*
* `HISTCONTROL`:如果设置为ignorespace, 以 space 开头的行将不会插入到历史列表中。 如果设置为 ignoredups, 匹配上一次历史记录的行将不会插入。设置为 ignoreboth 会结合这两种选项。如果没有定义，或者设置为其他值，所有解释器读取的行都将存入历史列表，但还要经过 HISTIGNORE 处理。这个变量的作用可以被 HISTIGNORE 替代。多行的组合命令的第二和其余行都不会被检测，不管 HISTCONTROL 是什么，都会加入到历史中。
* `HISTFILE`:保 存 命 令 历史的文件名 (参见下面的 HISTORY 历史章节)。默认值是`~/.bash_history`。如果取消定义，在交互式 shell 退出时命令历史将不会保存。
* `HISTFILESIZE`:历史文件中包含的最大行数。当为这个变量赋值时，如果需要的话，历史文件将被截断来容纳不超过这个值的行。默认值是 500。历史文件在交互式 shell 退出时也会被截断到这个值。
* `HISTIGNORE`:一个冒号分隔的模式列表，用来判断那个命令行应当保存在历史列表中。每个模式都定位于行首，必须匹配整行 (没有假定添加 ‘*’)。在HISTCONTROL指定的测试结束后，这里的每个模式都要被测试。除了平常的shell 模式匹配字符， ‘`&`’ 匹配上一个历史行。‘`&`’ 可以使用反斜杠来转义；反斜杠在尝试匹配之前将被删除。多行的组合命令的第二行以及后续行都不会被测试，不管 HISTIGNORE 是什么，都将加入到历史中。
* `HISTSIZE`:命令历史中保存的历史数量 (参见下面的 HISTORY 历史章节)。默认值是500。
* `HOME`:当前用户的个人目录；内建命令 cd 的默认参数。在执行波浪线扩展时也用到这个变量。
* `HOSTFILE`:包含一个格式和 `/etc/hosts` 相同的文件名，当 shell 需要补全主机名时要读取它。shell 运行过程中可以改变可能的主机名补全列表；改变之后下一次需要主机名补全时 bash 会将新文件的内容添加到旧列表中。如果定义了HOSTFILE 但是没有赋值，bash 将尝试读取`/etc/hosts`文件来获得可能的主机名补全列表。当取消 HOSTFILE 的定义时，主机名列表将清空。
* `IFS`内部字段分隔符 Internal Field Separator 用来在扩展之后进行分词，使用内部命令read将行划分成词。默认值是`‘‘<space><tab><newline>’’`。
* `IGNOREEOF`:控制交互式 shell 接受到唯一一个 EOF 字符时的行为。如果有定义，值是需要在一行的开始连续输入`EOF`字符，直到可以使 bash 退出的字 符个数。如果这个变量存在，但是值不是一个数字或者没有赋值，默认值是10。如果变量没有定义， EOF 标志着输入的结束。
* `INPUTRC`readline 的启动配置文件，而不是默认的 `~/.inputrc` (参 见 下 面 的READLINE 章节)。
* `LANG`用来决定没有特地用 `LC_` 变量指定的语言环境项。
  * `LC_ALL`这个变量超越了 LANG 和所有其他指定语言环境项的 LC_ 变量。
  * `LC_COLLATE`这个变量决定了为路径扩展的结果排序时的字母顺序，决定了范围表达式的行为，等价类，和路径扩展中的归并顺序以及模式匹配。
  * LC_CTYPE这个变量决定了字符的解释和路径扩展以及模式匹配中字符类的行为。
  * LC_MESSAGES:这个变量决定了翻译以`$`前导的双引号字符串时的语言环境。
  * LC_NUMERIC:这个变量决定了格式化数字时的语言环境分类。
  * LINES  内建命令 select 用它来判断输出选择列表时的列宽度。在收到SIG-WINCH 信号时自动设置。MAIL如果这个参数设置为一个文件名，并且没有设置环境变量 MAILPATH 的话，bash 将在这个文件中通知用户有邮件到达。
* MAILCHECK:指定 bash 检查邮件的频率是多少，以秒为单位。默认值是 60 秒。需要检查邮件的时候，shell 在显示提示符之前将进行检查。如果取消它的定义，或者设置为并非大于等于零的数值，shell 将禁止邮件检查。
* MAILPATH一个冒号分隔的文件名列表，从中检查邮件。当邮件到达某个特殊文件中时 ，输出的特定消息可以通过将文件名与消息以 ‘?’ 分隔来指定。在消息的文本中，`$_ `扩展为当前邮件文件的文件名。例如：`MAILPATH=’/var/mail/bfox?"You  have  mail":~/shell-mail?"$_  hasmail!"’`Bash  为这个变量提供默认值，但是它使用的用户邮件文件的位置是系统相关的 (例如，`/var/mail/$USER`)。
* OPTERR 如果设置为 1， bash 显示内建命令 getopts 产生的错误消息 (参见 下面的 shell 内建命令(SHELL BUILTIN COMMANDS) 章节)。每次 shell 启动时或者一个 shell 脚本被执行时 OPTERR 被初始化为 1。PATH搜索命令的路径。它是一个冒号分割的目录列表，shell 从中搜索命令 (参见下面的 命令执行(COMMAND EXECUTION) 段落)。默认的路径是系统相关的，是由安装 bash 的系统管 理 员 设 置 的 。 通 常 它 的 值 是`‘‘/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.’’`。
* `POSIXLY_CORRECT`:如 果  bash 启动环境中有这个变量，它将在读取启动配置文件之前进入posix mode，就好像提供了 --posix 启动参数一样。如果 shell 运行过程 中设置了它，bash 就启用 posix mode，就好像执行了`set -o posix`命令一样。
* `PROMPT_COMMAND`如果有定义，它的值将作为一个命令，每次显示主提示符之前都会执行。
* `PS1`:这个参数的值被扩展 (参见下面的 PROMPTING 提示符段落)，用作主提示符字符串。默认值是 `‘‘\s-\v\$ ’’`。
* `PS2`:这个参数的值同 PS1 一起被扩展，用作次提示符字符串。默认值是  `‘‘>’’`。
* `PS3`:这 个参数的值被用作内建命令`select`的提示符 (参见上面的 SHELL GRAMMAR 语法章节)。
* `PS4`:这个参数的值同 PS1 一起被扩展，在执行跟踪中在 bash 显示每个命令之前显示。需要的话， PS4 的第一个字符会被复制多次，来指示 indirection 的层数。默认值是 ‘‘+ ’’。
* `TIMEFORMAT`:在前缀time保留字的管道中，这个参数的值用作格式字符串，指定计时信息如何显示。字符 % 引入的转义序列，被扩展为时间值或其他信息。转义序列和它们的含义如下所示；括号中是可选的成分。
    * `%%`:一个字面上的`%`。
    * `%[p][l]R`:经历的时间，以秒计算。
    * `%[p][l]U`:CPU 在用户模式下执行的秒数。
    * `%[p][l]S`:CPU 在系统模式下执行的秒数。
    * `%P`:CPU 使用率，算法是 `(%U + %S) / %R`。
      * 可选的 p 是指定精度 (小数点后数字位数) 的数值。如果是0就不输出小数点或小数值。最多指定到小数点后三位；如果 p 大于 3 就会被改为
          3。如果没有指定 p，默认使用 3。
      * 可选的 l 指定了长格式，包含分钟，格式是`MMmSS.FFs`。 p 的值决定了是不是包含小数位。
      * 如  果  没  有  设  置  这  个  值  ，bash     假 定 它 的 值 是`$’\nreal\t%3lR\nuser\t%3lU\nsys%3lS`’。如果它是空值，就不会显示计时信息。显示格式字符串的时候，会加上一个前导的新行符。
 * `TMOUT`如果设置为大于 0 的值，`TMOUT`被当作内建命令 read 的默认超时等待时间。如果等待终端输入时，`TMOUT`秒之后仍然没有输入， `select `命令 将终止。在交互的 shell 中，它的值被解释为显示了主提示符之后等待输入的秒数。如果经过这个秒数之后仍然没有输入， Bash 将退出。
* auto_resume:这个变量控制了 shell 如何与用户和作业控制交互。如果设置了这个 变量，一个不包含重定向的单个词的简单命令，将作为恢复被中断的作业的指示。不允许出现模棱两可的情况；如果有多个作业都以这个词起始，将恢复最近运行的作业。在这种情形下，被中断的作业的 name 是用于启动它的命令行。如果值设置为 exact，给出的字符串必须精确匹配被中断的作业名；如果设置为 substring，给出的字符串需要匹配被中断的作业名的子串。值 substring 的功能与作业标识符 %?  功能类似 (参见下面的OB  CONTROL 作业控制章节)。如果设置为任何其他值，给出的字符串必须是被中断的作业的前缀；这样做与作业标识符 % 功能类似。
 
* histchars：两到三个字符，控制着历史扩展和分段 (tokenization，参 见 下 面 的HISTORY EXPANSION 历史扩展章节)。第一个字符是 history expansion(历史扩展) 字符，这个字符表明了历史扩展的开始，通常是 `‘!’`。第二个字符是quick substitution(快速替换) 字符，它是重新运行上次输入的命令，但将命令中的字符串替换为另一个的简写，默认是 `‘^’`。可选的第三个字符是指示如果作为一个词的开始，那么一行中剩余字符是注释。通常这个字符是 `‘#’`。历史注释字符使得对一行中剩余字符在历史替换中被跳过。它不一定使 shell 解释器将这一行的剩余部分当作注释。
 
 # 4. arrays
 **Bash提供了一维数组变量**。**任何变量都可以作为一个数组**；内建命令 `declare`可以显式地定义数组。数**组的大小没有上限**，**也没有限制在连续对成员引用和赋值时有什么要求**。数组以整数为下标，从 0 开始。

## 4.1 申明
 如果变量赋值时使用语法`name[subscript]=value`，那么就会自动创建数组。subscript被当作一个算术表达式，结果必须是大于等于 0 的值。要显式地定义一个数组，使用`declare -a name`(参见下面的 shell 内建命令(SHELL BUILTIN COMMANDS) 章节)。也可以用 `declare -a name[subscript]`这时subscript被忽略。数组变量的属性可以用内建命令 declare 和 readonly 来指定。每个属性对于所有数组元素都有效。

## 4.2 赋值
 数组赋值可以使用复合赋值的方式，形式是`name=(value1 ... valuen)`，这里每个value的形式都是 `[subscript]=string`。string必须出现。如果出现了可选的括号和下标，将为这个下标赋值，否则被赋值的元素的下标是语句中上一次 赋值 的下标加一。下标从`0`开始。这个语法也被内建命令`declare`所接受。单独的数组元素可以用上面介绍的语法`name[subscript]=value`来赋值。

数组的任何元素都可以用`${name[subscript]}`来引用。**花括号是必须的**，以避免和路径扩展冲突。如果 subscript 是`@`或是`*`，它扩展为 name 的所有成员。这两种下标只有在双引号中才不同。

* 在双引号中，`${name[*]}` 扩展为一个词，由所有数组成员的值组成，用特殊变量IFS的第一个字符分隔；
* `${name[@]}`将name 的每个成员扩展为一个词。

如果数组没有成员，`${name[@]}`扩展为空串 。这种不同类似于特殊参数`*`和`@`的扩展 (参见上面的 Special Parameters 段落)。`${#name[subscript]}`扩展为`${name[subscript]} 的长度`。 如果subscript是`*`或者是`@`，扩展结果是数组中元素的个数。引用没有下标数组变量等价于引用元素0。

 ## 4.3 销毁
内建命令 unset 用于销毁数组。`unset name[subscript]`将销毁下标是sub-script的元素。 `unset name`, 这里name是一个数组，或者`unset name[sub-script]`, 这里`subscript`是`*`或者是`@`，将销毁整个数组。

内建命令`declare`, `local`, 和`readonly`都能接受`-a`选项，从而指定一个数组。 内建命令`read`可以接受`-a`选项，从标准输入读入一列词来为数组赋值。内建命令`set`和`declare`使用一种可以重用为输入的格式来显示数组元素