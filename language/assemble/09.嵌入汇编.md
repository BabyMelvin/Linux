GNU 汇编语言定义函数的语法:

```asm
.type 标签(也就是函数名), @function
ret 返回到调用处
```

# 嵌入汇编

C程序中嵌入汇编代码，具体输入和输出参数的嵌入汇编语句的基本格式为：

```
asm("汇编语句"
	:输出寄存器
	:输入寄存器
	:会被修改的寄存器);
```

* 除第1行外，后面带冒号都可以省略
* asm:内联汇编关键字。
* 输出寄存器，汇编执行完之后，哪些寄存器用于存放输出数据，寄存器分别对应C语言表达式值或一个内存地址
* 输入寄存器：开始执行汇编代码时，指定的一些寄存器中存放的输入值，分别对应着C变量或常数值。
* 会被修改的寄存器：你对其列出来的寄存器值进行了改动,gcc编译器不能再依赖于原先对这些寄存器加载的值。如必要话，gcc需要重新加载这些寄存器.`kernel/traps.c`

## example 1
```c
01 #define get_seg_byte(seg,addr) \
02 ({ \
03 register char __res; \  //定义一个寄存器变量__res
04 __asm__("push %%fs; \  //先保存fs寄存器原值
05 		mov %%ax,%%fs;\ //然后用seg设置fs
06 		movb %%fs:%2,%%al; \ //取set:addr处一个字节内容到al寄存器中
07 		pop %%fs"   \      //恢复fs寄存器原内容
08 		:"=a" (__res) \    //输出寄存器列表
09 		:"0" (seg),"m" (*(addr))); \ //输出寄存器列表
10 __rest;})
```

* 使用汇编语言最好的方式就是放入宏中，用圆括号括住的组合语句(花括号中的语句):`({})`可作为表达式使用，其中最后一行`__res`是该表达式的输出值。__res是寄存器变量，便于快速访问。如果想指定寄存器(如`eax`)，可以写成`register char __res asm("ax");`,其中asm可写为`__asm__`。为了让gcc编译产生的汇编语言中寄存器名称前有一个百分号"%"，在嵌入汇编语句寄存器名称必须写上两个百分号`%%`。
* 第8行，函数输出值`=a`的a称为加载代码，`=`表示输出寄存器，并且其中的值将被输出值代替
* 第9行开始运行时将这段代码运行时将seg放到eax寄存器中，"0"表示使用与上面同个位置输出相同的寄存器，而`*(addr)`表示一个内存偏移地址。嵌入汇编编程规定输出和输入寄存器统一顺序编号，顺序是输出寄存器序列从左到右从上到下以`%0`开始，分别记为`%0`,`%1`,...`%9`,因此输出寄存器的编号是`%0`(这里只有一个输出寄存器)，输入寄存器前一部分`("0"(seg))`的编号是`%1`，而后面部分编号是`%2`。
* 第6行上的`%2`即代表`(*(addr))`这个内存偏移量
* 第4行将fs段寄存器的内容入栈
* 第5句将eax中的段值赋给fs段寄存器；
* 第6句是把`fs:(*(addr))`所指定的字节放入al寄存器中。当执行完汇编语句后，输出寄存器eax的值将被放入__res，作为该宏函数的返回值


宏名称中seg代表指定的内存段值，而addr表示内存偏移地址量。

## example 2

```c
01 asm("cld\n\t"
02 	"rep\n\t"
03 	"stol"
04 	:/*没有输出寄存器*/
05 	:"c"(count-1),"a"(fill_value),"D"(dest)
06	:"%ecx","%edi");
```

* 01-03:通常的汇编语句，清方向位，重复保存值。`\n\t`用于gcc预处理程序输出程序列表能拍的整齐而设置，字符的含义与C语言中相同。
* 04：嵌入汇编程序没有用到输出寄存器。
* 05：将count-1的值加载到ecx寄存器中(加载代码"c")，