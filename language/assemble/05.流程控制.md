# 1.无条件跳转
## 1.1 跳转
`jmp location`其中location为要跳转到的内存地址, 在汇编中为定义的**标签**

## 1.2 调用
调用指令分为两部分：

* 1调用 call address 跳转到指定位置
* 2返回指令ret, 它没有参数紧跟在call 指令后面的位置

执行call指令时，它把EIP的值放到堆栈中， 然后修改EIP以指向被调用的函数地址，当被调用函数完成后，它从堆栈获取过去的EIP的
值，并把控制权返还给原始程序。

## 1.3中断
由硬件设备生成中断。 程序生成软件中断当一个程序产生中断调用时, 发出调用的程序暂停, 被调用的程序接替它运行, 指令指针被转移到被调用的函数地址，当调用完成时使用中断返回指令可以返回调原始程序。

# 2.条件跳转
条件跳转按照EFLAGS中的值来判断是否该跳转, 格式为:`jxx address`,其中 xx是 1－3个字符的条件代码, 取值如下:

* a 大于时跳转
* ae 大于等于
* b 小于
* be 小于等于
* c 进位
* cxz 如果CX 寄存器为0
* ecxz 如果ECS 寄存器为0
* e 相等
* na 不大于
* nae 不大于或者等于
* nb 不小于
* nbe 不小于或等于
* nc 无进位
* ne 不等于
* g 大于(有符号)
* ge 大于等于(有符号)
* l 小于(有符号)
* le 小于等于(有符号)
* ng 不大于(有符号)
* nge 不大于等于(有符号)
* nl 不小于
* nle 不小于等于
* no 不溢出
* np 不奇偶校验
* ns 无符号
* nz 非零
* o 溢出
* p 奇偶校验
* pe 如果偶校验
* po 如果奇校验
* s 如果带符号
* z 如果为零

条件跳转不支持分段内存模型下的远跳转， 如果在该模式下进行程序设计必须使用程序逻辑确定条件是否存在, 然后实现无条件跳转, **跳转前必须设置EFLAGS寄存器**

# 3.比较

`cmp operand1,operand2`

# 4.进位标志修改指令

* CLC 清空进位标志(设置为 0)
* CMC 对进位标志求反(把它改变为相反的值)
* STC 设置进位标志(设置为 1)

# 5.循环

* loop 循环直到 ECX 寄存器为 0
* `loope/loopz` 循环直到 ecx寄存器为 0 或者没有设置 ZF 标志
* `loopne/loopnz` 循环直到 ecx为0 或者设置了 ZF 标志

指令格式为:`loopxx address`注意循环指令只支持8位偏移地址