# 1.加法
`ADD source, destination`把两个整数相加
其中source 可以是立即数内存或者寄存器, destination 可以是内存或者寄存器, 但是两者不能同时都是内存位置
ADC 和ADD相似进行加法运算, 但是它把前一个 ADD指令的产生进位标志的值包含在其中, 在处理位数大于32(如 64)
位的整数时, 该指令非常有用
# 2.减法
`SUB source, destination`把两个整数相减

* NEG 它生成值的补码
SBB 指令, 和加法操作一样, 可以使用进位情况帮助执行大的无符号数值的减法运算. SBB 在多字节减法操作中利用进位和溢出标志实现跨
数据边界的的借位特性

# 3.递增和递减

* `dec destination`递减
* `inc destination` 递增

其中dec 和 inc 指令都**不会影响进位标志**, 所以递增或递减计数器的值都不会影响程序中涉及进位标志的其他任何运算

# 4.乘法
* `mul source`进行无符号数相乘它使用隐含的目标操作数, 目标位置总是使用 eax 的某种形式, 这取决与源操作数的长度， 因此根据源操作数的长度,目标操作数必须放在AL, AX, EAX 中。 此外由于乘法可能产生很大的值, 目标位置必须是源操作数的两倍位置, 源为8时, 应该是 16, 源为16时, 应该为32, 但是当源为16 位时 intel 为了向下兼容, 目标操作数不是存放在eax中, 而是分别存放在DX:AX 中, 结果高位存储在DX 中, 地位存储在AX 中。对于32 位的源, 目标操作数存储在 EDX:EAX 中, 其中 EDX 存储的是高32位, EAX 存储的是低32位
* `imul source` 进行有符号数乘法运算, 其中的目标操作数和 mul的一样imul source, destination 也可以执行有符号乘法运算, 但是此时可以把目标放在指定的位置, 使用这种格式的缺陷在与乘法的操作结果被限制为单一目标寄存器的长度.
* `imul multiplier, source, destination`其中multiplier 是一个立即数, 这种方式允许一个值与给定的源操作数进行快速的乘法运算, 然后把结果存储在通用寄存器中

# 5.除法
* `div divisor`执行无符号数除法运算除数的最大值取决与被除数的长度, 对于 16位被除数 ,除数只能为8 位, 32 或 64位同上被除数 被除数长度 商 余数
	* AX 16 位 AL AH
	* DX:AX 32 位 AX DX
	* EDX:EAX 64 位 EAX EDX
* `idiv divisor` 执行有符号数的除法运算, 方式和 div一样

# 6.移位
## 6.1 左移位
sal 向左移位

* `sal destination` 把 destination 向左移动 1位
* `sal %cl, destination` 把 destination 的值向左移动CL寄存器中指定的位数
* `sal shifter, destination` 把 destination 的值向左移动 shifter 值指定的位数

向左移位可以对带符号数和无符号数执行向左移位的操作, 移位造成的空位用零填充, 移位造成的超过数据长度的任何位都被存放在进位标志中, 然后在下一次移位操作中被丢弃

## 6.2 向右移位
shr 向右移位

* SHR 指令清空移位造成的空位, 所以它只能对无符号数进行移位操作
* SAR 指令根据整数的符号位, 要么清空, 要么设置移位造成的空位, 对于负数, 空位被设置为1

## 6.3循环移位
和移位指令类似, 只不过溢出的位被存放回值的另一端, 而不是丢弃

* ROL 向左循环移位
* ROR 向右循环移位
* RCL 向左循环移位, 并且包含进位标志
* RCR 向右循环移位, 并且包含进位标志

# 7.逻辑运算
## 7.1 AND OR XOR

这些指令使用相同的格式:`and source, destination`

其中source 可以是8位 16 位或者 32 位的立即值 寄存器或内存中的值, destination 可以是 8 位 16 位或者 32位寄存器或内存中的值,不能同时使用内存值作为源和目标。 布尔逻辑功能对源和目标执行按位操作。也就是说使用指定的逻辑功能按照顺序对数据的元素的每个位进行单独比较。

## 7.2 NOT
NOT 指令使用单一操作数, 它即是源值也是目标结果的位置清空寄存器的最高效方式是使用 OR 指令对寄存器和它本身进行异或操作.当和本身进行XOR操作时, 每个设置为1的位就变为0， 每个设
置为0 的位也变位0。

## 7.3位测试
位测试可以使用以上的逻辑运算指令, 但这些指令会修改 destination 的值, 因此 intel 提供了test指令, 它不会修改目标值而是设置相应的标志