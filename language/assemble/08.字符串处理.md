# 1.传送字符串
* movs 有三种格式
* movsb 传送单一字节
* movsw 传送一个字
* movsl 传送双字

movs 指令使用隐含的源和目的操作数， 隐含的源操作数是 ESI， 隐含的目的操作数是 EDI， 有两种方式加载内存地址到ESI 和EDI，

* 第一种是使用标签间接寻址`movl $output, %ESI`
* 第二种是使用lea 指令, lea 指令加载对象的地址到指定的目的操作数如`lea output,%esi`, 每次执行 movs 指令后， 数据传送后 ESI 和EDI 寄存器会自动改变，为另一次传送做准备, ESI 和 EDI 可能随着标志DF 的不同自动递增或者自动递减， 如果DF 标志为0 则 movs 指令后 ESI 和EDI 会递增, 反之会递减， 为了设置 DF 标志, 可以使用一下指令:

* CLD 将DF 标志清零
* STD 设置DF 标志
# 2.rep 前缀

REP 指令的特殊之处在与它不执行什么操作, 这条指令用于按照特定次数重复执行字符串指令, 有 ECX 寄存器控制,但不需要额外的loop 指
令, 如`rep movsl`
rep 的其他格式:

* repe 等于时重复
* repne 不等于时重复
* repnz 不为零时重复
* repz 为零时重复

# 3. 存储和加载字符串
* LODS 加载字符串, ESI 为源, 当一次执行完 lods 时会递增或递减 ESI 寄存器， 然后把字符串值存放到EAX 中
* STOS 使用lods 把字符串值加载到EAX 后， 可以使用它把EAX 中的值存储到内存中去:
stos 使用 EDI 作为目的操作数, 执行stos 指令后, 会根据 DF 的值自动递增或者递减EDI 中的值

# 4.比较字符串
cmps 和其他的操作字符串的指令一样, 隐含的源和目标操作数都为 ESI 和EDI, 每次执行时都会根据DF 的值把
ESI 和EDI 递增或者递减, cmps 指令从目标字符串中减去源字符串, 执行后会设置 EFLAGS 寄存器的状态.

# 5.扫描字符串
scas 把 EDI 作为目标, 它把 EDI 中的字符串和 EAX 中的字符串进行比较 ,然后根据 DF 的值递增或者递减EDI