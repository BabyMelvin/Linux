# 1.GCC Inline ASM汇编的语法

GCC支持在C/C++代码中嵌入汇编代码，这些汇编代码被称为GCC Inline ASM---GCC内联汇编。这样做可以将一些C/C++无法语言无法表达的指令直接嵌入C/C++代码中，另外也允许我们直接写C/C++代码中使用汇编编写简洁高效的代码。

GCC基本内联汇编非常易懂，写简答例子：

```asm
__asm__("movl %esp,%eax");
//或者
__asm__("
  movl $1,%eax  //SYS_exit xor%e
  bx,ebx
   int $0x80
");
//或
__asm__(
  "movl $1,%eax/r/t"
  "xor %ebx,%ebx/r/t"
  "int %0x80"
);
```
基本内联汇编的格式是：

```asm
__asm__volatitle__("InstructionList");
```

## 1.1__asm__
__asm__是GCC关键字asm的宏定义：

```c
#define __asm__ asm
```
__asm__或asm用来声明一个内联汇编表达是，所以一个任何内联汇编表达是都是以它开头是必不可少的

## 1.2InstructionList
InstructionList是汇编指令序列。可以时空比如：`__asm__volatile__("")；`或者`__asm__("")；`都是合法的内联汇编表达式，只不过两句没有什么意义。但并非所有InstructionList为空的内联汇编表达式都是没有意义的，比如`__asm__("":::"memory");`就是非常有意义，向GCC声明："我对内存作了改动"，GCC编译的时候会将此因素考虑进去。

例子：

```asm
//example1.c
int main(int __argc,char* __argv[]){
	int *__p=(int*)__argc;
	(*__p)=9999;

	//__asm__("":::"memory");
	if((*__p)==9999)
		return 5;
	return (*__p);
}
```

这代码中，内联汇编被注释掉的。这条内联汇编之前，内存指针__p指向的内存被赋值为9999，对弈出现if语句判断__p所指向的内存与9999是否相等，很明显是相等的。使用下面语句进行编译：

```asm
$gcc -O -S example1.c
```

* `-O`:表示优化编译，可以指定优化等级，比如`-O2`表示优化等级为2；
* `-S`:表示将C/C++源文件编译为汇编文件，文件名和C/C++一样，只不过扩展名由`.c`变为`.s`.结果为：

```asm
	.file	"example1.c"
	.text
	.globl	main			 #声明为全局	
	.type	main, @function  #声明函数
main:
.LFB39:
	.cfi_startproc
	movslq	%edi, %rdi     #int *__p=(int*)__argc;
	movl	$9999, (%rdi)  #(*__p)=9999;
	movl	$5, %eax       #return 5;
	ret
	.cfi_endproc
.LFE39:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"
	.section	.note.GNU-stack,"",@progbits
```
