# 1.数据段
使用`.data `明数据段, 这个段中声明的任何数据元素都保留在内存中并可以被汇编程序的指令读取,此外还可以使用`.rodata`声明只读的数据段, 在声明一个**数据元素**时, 需要使用标签和命令:

* 标签:用做引用数据元素所使用的标记， 它和 c 语言的**变量很相似**, 它对于处理器是没有意义的, 它只是用做汇编器试图访问`内存位置`时用做引用指针的一个位置。
* 指令:这个名字指示汇编器为`通过标签引用`的`数据元素`保留特定数量的内存， 声明命令之后必须给出一个或多个**默认值**。

## 1.1 声明指令

```S
.ascii 文本字符串
.asciz 以空格字符结尾的字符串
.byte 字节值
.double 双精度浮点值
.float 单精度浮点值
.int 32为整数
.long 32位整数，和int相同
.octa 16字节整数
.quad 8字节整数
.short 16为整数
.single 单精度浮点数(和float相同)
```

例子：

```S
output:
.ascii "Hello world."

pi:
.float 3.14

//声明可以一行中定义多个值
ages:
.int 20,10,30,40

//定义静态符号，使用.equ命令把常量值定义为可以在文本段中使用的符号，如：

.section .data
.equ LINUX_SYS_CALL,0x80
.section .text
movl $LINUX_SYS_CALL,%eax
```

# 2.bss段
和 data 段不同, **无需声明特定的数据类型**, 只需声明为所需目的保留的`原始内存部分`即可。GNU 汇编器使用以下两个命令声明内存区域:

* `.comm` 声明为未初始化的通用内存区域
* `.lcomm` 声明为未初始化的本地内存区域

两种声明很相似， 但`.lcomm`是为不会从本地汇编代码之外进行访问的数据保留的， 格式为:
`.comm/.lcomm symbol, length`

例子:

```S
.section .bss
.lcomm buffer, 1000
```
该语句把1000字节的内存地址赋予标签buffer, 在声明本地通用内存区域的程序之外的函数是不能访问他们的.(不能在`.globl`命令中使用他
们)

在**bss段**声明的好处是, **数据不包含在可执行文件中**。在数据段中定义数据时, 它必须被包含在可执行程序中, 因为必须使用特定值初始化它。
因为不使用数据初始化bss 段中声明的数据区域,所以内存区域被保留在运行时使用, 并且不必包含在最终的程序中.

# 3.传递数据
## 3.1 move指令
move 指令:格式 `movex 源操作数, 目的操作数`。 其中x 为要传送数据的长度, 取值有:

* l 用于 32位的长字节
* w 用于16位的字
* b 用于8 位的字节值

立即数前面要加一个$符号, 寄存器前面要加%符号。

8个通用的寄存器是用于保存数据的最常用的寄存器, 这些寄存器的内容可以传递给其他的任何可用的寄存器。 和通用寄存器不同, **专用寄存
器**(控制, 调试, 段)的**内容只能传送给通用寄存器**, **或者接收从通用寄存器传过来的内容**。

在对标签进行引用时:

```S
.section .data
value:
.int 100

_start:
movl value,%eax
movl $value,%eax
movl %ebs,(%edi)
movl %ebx,4(%edi)
```
其中:

* `movl value, %eax`只是把标签value当前引用的**内存值**传递给eax
* `movl $value, %eax`把标签 value 当前引用的内存地址指针传递给 eax
* `movl %ebx, (%edi)` 如果 edi外面没有括号那么这个指令只是把 ebx中的**值**加载到edi 中, 如果有了括号就表示把 ebx中的**内容**传送给edi 中包含的内存位置。
* `movl %ebx, 4（%edi)`表示把edi中的值放在edi指向的位置之后的4 字节内存位置中
* `movl %ebx, -4(%edi)`表示把 edi中的值放在 edi 指向的位置之前的 4字节内存位置中

## 3.2 cmove指令(条件转移)
格式：`cmovex 源操作数, 目的操作数`.x的取值为:

* 无符号数：
	* `a/nbe` 大于/不小于或者等于
	* `ae/nb` 大于或者等于/不小于
	* `nc` 无进位
	* `b/nae` 小于/不大于等于
	* `c` 进位
	* `be/na` 小于或等于/不大于
	* `e/z` 等于/零
	* `ne/nz` 不等于/不为零
	* `p/pe` 奇偶校验/偶校验
	* `np/po` 非奇偶校验/奇校验
* 有符号数：
	* `ge/nl` 大于或者等于/不小于
	* `l/nge` 小于/不大于或者等于
	* `le/ng` 小于或者等于/不大于
	* `o` 溢出
	* `no` 未溢出
	* `s` 带符号（负)
	* `ns` 无符号(非负)

## 3.3 交换数据
* xchg 在两个寄存器之间或者寄存器和内存间交换值如:`xchg 操作数, 操作数`, 要求两个操作数必须长度相同且不能同时都是内存位置,其中寄存器可以是32，16，8 位的bswap 反转一个32 位寄存器的字节顺序如: `bswap %ebx`
* xadd 交换两个值 并把两个值只和存储在目标操作数中如: `xadd 源操作数,目标操作数`.其中源操作数必须是寄存器, 目标操作数可以是内存位置也可以是寄存器其中寄存器可以是 32，16，8位的
* cmpxchg:`cmpxchg source, destination`.其中source 必须是寄存器, destination 可以是内存或者寄存器, 用来比较两者的值, 如果相等，就把源操作数的值加载到目标操作数中, 如果不等就把目标操作数加载到源操作数中，其中寄存器可以是 32，16，8 位的, 其中源操作数是EAX,AX 或者 AL寄存器中的值
* cmpxchg8b 同 cmpxchg， 但是它处理 8 字节值， 同时它只有一个操作数`cmpxchg8b destination` 其中 destination 引用一个内存位置, 其中的 8 字节值会与 EDX 和EAX 寄存器中包含的值(EDX 高位寄存器,EAX低位寄存器)进行比较, 如果目标值和 EDX:EAX 对中的值相等, 就把 EDX:EAX 对中的 64 位值传递给内存位置, 如果不匹配就把内存地址中的值加载到EDX:EAX 对中

# 4.堆栈
ESP寄存器保存了当前**堆栈**的起始位置, 当一个数据压入栈时， 它就会自动递减, 反之其自动递增.

压入堆栈操作:`pushx source,x`，x取值为：

* l 32位长字
* w 16位字

弹出堆栈操作:`popx source`,其中source 必须是16或32 位寄存器或者内存位置, 当pop**最后一个元素**时ESP值应该和以前的相等

# 5.压入和弹出所有寄存器

* `pusha/popa`压入或者弹出所有 16位通用寄存器
* `pushad/popad`压入或者弹出所有32位通用寄存器
* `pushf/popf`压入或者弹出EFLAGS 寄存器的低16 位
* `pushfd/popfd`压入或者弹出EFLAGS 寄存器的全部 32 位

# 6，数据地址对齐
gas 汇编器支持`.align`命令， 它用于在特定的内存边界对准定义的数据元素， 在数据段中`.align` 命令紧贴在**数据定义的前面**