# 1.编译C程序的隐含规则。

* `<n>.o`的目标的依赖目标会自动推导为`<n>.c`，并且其生成命令：`$(CC) –c $(CPPFLAGS) $(CFLAGS)`

# 2.链接Object文件的隐含规则。
`<n>` 目标依赖于`<n>.o`，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：`$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)`。
## 2.1可以自己写ld链接规则(-T)
`$(CC) $(LDFLAGS) -T myld.ld $(SRC) vector.o -o main`
		其中`myld.ld`关于内存的一些信息。
# 3.隐含规则使用的变量
make的`-R`或`--no– builtin-variables`参数来取消你所定义的变量对隐含规则的作用。
1.关于命令的变量。
	
* `AR`   函数库打包程序。默认命令是“ar”。
*  `RM`   删除文件命令。默认命令是“rm –f”。

2.关于命令参数的变量

* `ARFLAGS`  函数库打包程序AR命令的参数。默认值是`rv`。
*  `CFLAGS`   C语言编译器参数

# 4.隐含规则链
# 5.定义模式规则
`%`的意思是表示一个或多个任意字符。在依赖目标中同样可以使用`%`，只是依赖目标中的`%`的取值，取决于其目标。

## 5.1 模式规则介绍
`%.o : %.c ; <command ......>`
	
## 5.2 模式规则示例
`$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@`

## 5.3 自动化变量

* `$@` 就是匹配于目标中模式定义的集合。
* `$%`	仅当目标是函数库文件中，表示规则中的目标成员名。
- `$<`  依赖目标中的第一个目标名字。如果依赖目标是以模式（即`%`）定义的，那么`$<`将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
* `$? ` 所有比目标新的依赖目标的集合。以空格分隔。
* `$^`  所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。
* `$+`  这个变量很像`$^`，也是所有依赖目标的集合。只是它不去除重复的依赖目标。
*  `$*`  这个变量表示目标模式中`%`及其之前的部分。
