# 1.make 命令
想让 make 重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则

## 1.1 make的退出码

make 命令执行后有三个退出码：

* 0 表示成功执行。
* 1 如果 make 运行时出现任何错误，其返回 1。
* 2 如果你使用了 make 的“-q”选项，并且make使得一些目标不需要更新，那么返回 2。

## 1.2 指定Makefile
GNU make 找寻默认的 Makefile 的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。

当前，我们也可以给 make 命令指定一个特殊名字的 Makefile。要达到这个功能，我们要使用 make的`-f`或是`--file`参数（`--makefile`参数也行）。例如，我们有个 makefile 的名字是“hchen.mk”，那么，我们可以这样来让 make 来执行这个文件：`make –f hchen.mk`

## 1.3 指定目标
任何在 makefile 中的目标都可以被指定成终极目标，但是除了以`-`打头，或是包含了 = 的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make 的终极目标.

有一个 make 的环境变量叫 MAKECMDGOALS ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：

```make
sources = foo.c bar.c
ifneq ( $(MAKECMDGOALS),clean)
	include $(sources:.c=.d)
endif
```

我们可以参照这种规则来书写我们的 makefile 中的目标。

* all: 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
* clean: 这个伪目标功能是删除所有被 make 创建的文件。
* install: 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件**拷贝到指定的目标中去**。
* print: 这个伪目标的功能是例出**改变过的源文件**。
* tar: 这个伪目标功能是把源程序打包备份。也就是一个 tar 文件。
* dist: 这个伪目标功能是创建一个压缩文件，一般是把 tar 文件压成 Z 文件。或是 gz 文件。
* TAGS: 这个伪目标功能是更新所有的目标，以备完整地重编译使用。
* check 和 test: 这两个伪目标一般用来测试 makefile 的流程。

## 1.4 检查规则
有时候，我们不想让我们的 makefile 中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用 make 命令的下述参数：

* -n, --just-print, --dry-run, --recon 不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试 makefile 很有用处。
* -t, --touch 这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make 假装编
译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。
* -q, --question 这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。
* -W <file>, --what-if=<file>, --assume-new=<file>, --new-file=<file> 这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make 会根据规则推导来运行依赖于这个文件的命令，一般
来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。

## 1.5 make的参数

* -b, -m 这两个参数的作用是忽略和其它版本 make 的兼容性。
* -B, --always-make 认为所有的目标都需要更新（重编译）。
* -C `<dir>`,`--directory=<dir>` 指定读取 makefile 的目录。如果有多个“-C”参数，make 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“`make -C ~hchen/test
-C prog`”等价于“`make -C ~hchen/test/prog`”。
* `-debug[=<options>]` 输出 make 的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是`<options>`的取值：
	* a: 也就是 all，输出所有的调试信息。（会非常的多）
	* b: 也就是 basic，只输出简单的调试信息。即输出不需要重编译的目标。
	* v: 也就是 verbose，在 b 选项的级别之上。输出的信息包括哪个 makefile 被解析，不需要被重编译的依赖文件（或是依赖目标）等。
	* i: 也就是 implicit，输出所以的隐含规则。
	* j: 也就是 jobs，输出执行规则中命令的详细信息，如命令的 PID、返回码等
	*  m: 也就是 makefile，输出 make 读取 makefile，更新 makefile，执行 makefile 的信息。
* -d 相当于“–debug=a”。
* `-e, --environment-overrides`指明环境变量的值覆盖 makefile 中定义的变量的值。
* `-f=<file>`, `--file=<file>`, `--makefile=<file>` 指定需要执行的 makefile。
* -h, --help 显示帮助信息。
* -i , --ignore-errors 在执行时忽略所有的错误。
* `-I <dir>`, `--include-dir=<dir>` 指定一个被包含 makefile 的搜索目标。可以使用多个“-I”参数来指定多个目录。
* `-j [<jobsnum>]`,`--jobs[=<jobsnum>]`指同时运行命令的个数。如果没有这个参数，make 运行命
令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注
意这个参数在 MS-DOS 中是无用的）
* `-k`, `--keep-going`出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行
了。
* `-l <load>`, `--load-average[=<load>]`, `-max-load[=<load>]` 指定 make 运行命令的负载。
* `-n`, `--just-print`, `--dry-run`,`--recon`仅输出执行过程中的命令序列，但并不执行。
`-o <file>`, `--old-file=<file>`, `--assume-old=<file>`不重新生成的指定的 `<file>`，即使这个目标
的依赖文件新于它。
* `-p`, `--print-data-base`输出 makefile 中的所有数据，包括所有的规则和变量。这个参数会让一个简单的 makefile 都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make
-qp”命令。如果你想查看执行 makefile 前的预设变量和规则，你可以使用“`make –p –f /dev/null`”。这个参数输出的信息会包含着你的makefile 文件的文件名和行号，所以，用这个参数来调试你的makefile 会是很有用的，特别是当你的环境变量很复杂的时候。
* -q, --question 不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是 0 则说明要更新，如果是 2 则说明有错误发生。
* -r, --no-builtin-rules 禁止 make 使用任何隐含规则。
* -R, --no-builtin-variabes 禁止 make 使用任何作用于变量上的隐含规则。
* -s, --silent, --quiet 在命令运行时不输出命令的输出。
* -S, --no-keep-going, --stop 取消“-k”选项的作用。因为有些时候，make 的选项是从环境变量
“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。
* -t, --touch 相当于 UNIX 的 touch 命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。
* -v, --version 输出 make 程序的版本、版权等关于 make 的信息。
* -w, --print-directory 输出运行 makefile 之前和之后的信息。这个参数对于跟踪嵌套式调用 make 时很有用。
* --no-print-directory 禁止“-w”选项。
* `-W <file>`, `--what-if=<file>`, `--new-file=<file>`, `--assume-file=<file>` 假定目标 `<file>`; 需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行 UNIX 的“touch”命令一样，使得 `<file>;` 的修改时间为当前时间。

* `--warn-undefined-variables`只要 make 发现有未定义的变量，那么就输出警告信息。

# 2.隐含规则
“隐含规则”也就是一种惯例，make 会按照这种“惯例”心照不喧地来运行，那怕我们的`Makefile`
中没有书写这样的规则。例如，把`.c`文件编译成`.o` 文件这一规则，你根本就不用写出来，make 会自动推导出这种规则，并生成我们需要的`.o`文件

“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量`CFLAGS`可以控制编译时的编译器参数。

还可以通过“模式规则”的方式写下自己的隐含规则。

## 2.1 使用隐含规则
隐含规则是 make 事先约定好的一些东西。我们有下
面的一个 Makefile：

```make
foo : foo.o bar.o
	cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
```
这个 Makefile 中并没有写下如何生成 foo.o 和 bar.o 这两目标的规则和命令。因为 make 的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。

make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那
么就会报错。在上面的那个例子中，make 调用的隐含规则是，把 .o 的目标的依赖文件置成 .c ，并使用 C 的编译命令`cc –c $(CFLAGS) foo.c`来生成 foo.o 的目标。也就是说，我们完全没有必要写下下面的两条规则：

```make
foo.o : foo.c
	cc –c foo.c $(CFLAGS)
bar.o : bar.c
	cc –c bar.c $(CFLAGS)
```
当然，如果我们为 .o 文件书写了自己的规则，那么 make 就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。

## 2.2隐含规则一览

如果我们不明确地写下规则，那么，make 就会在这些规则中寻找所需要规则和命令。也可以使用 make 的参数 -r 或`--no-builtin-rules`选项来取消所有的预设置的隐含规则。

只要隐含规则中有“后缀列表”（也就一系统定义在目标 .SUFFIXES 的依赖目标），那么隐含规则就会生效。默认的后缀列表是：`.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s,.S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el`。

看一看常用的隐含规则吧:

1.**编译 C 程序的隐含规则**

`<n>.o`的目标的依赖目标会自动推导为`<n>.c`，并且其生成命令是`$(CC) –c $(CPPFLAGS) $(CFLAGS)`

2.**编译 C++ 程序的隐含规则**。

`<n>.o`的目标的依赖目标会自动推导为 <n>.cc 或是 <n>.C ，并且其生成命令是`$(CXX) –c$(CPPFLAGS) $(CFLAGS)`。

3.**链接 Object 文件的隐含规则**。
`<n>`目标依赖于`<n>.o`，通过运行 C 的编译器来运行链接程序生成（一般是 ld ），其生成命令是：`$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)`。这个规则对于只有一个源文件的工程有效，同时也对多个 Object 文件（由不同的源文件生成）的也有效。例如如下规则:

```make
x : y.o z.o
```

并且 x.c 、y.c 和 z.c 都存在时，隐含规则将执行如下命令:

```make
cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o
```

## 2.3  隐含规则使用的变量
在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的 makefile 中改变这些变量的值，或是在 make 的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用 make 的 -R 或 --no–builtin-variables 参数来取消你所定义的变量对隐含规则的作用。

第一条隐含规则——编译 C 程序的隐含规则的命令是 `$(CC) –c $(CFLAGS) $(CPPFLAGS)` 。Make 默认的编译命令是 cc ，如果你把变量`$(CC)`重定义成 gcc ，把变量`$(CFLAGS)`重定义成`-g`，那么，隐含规则中的命令全部会以`gcc –c -g $(CPPFLAGS)` 的样子来执行了。

我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如 CC ；一种是参数相的关，如CFLAGS 。下面是所有隐含规则中会用到的变量：

### 2.3.1 关于命令的变量

* AR : 函数库打包程序。默认命令是 ar
* AS : 汇编语言编译程序。默认命令是 as
* CC : C 语言编译程序。默认命令是 cc
* CXX : C++ 语言编译程序。默认命令是 g++
* CPP : C 程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E
* RM : 删除文件命令。默认命令是 rm –f

### 2.3.2 关于命令参数的变量
下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。

* ARFLAGS : 函数库打包程序 AR 命令的参数。默认值是 rv
* ASFLAGS : 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时）
* CFLAGS : C 语言编译器参数。
* CXXFLAGS : C++ 语言编译器参数。
* CPPFLAGS : C 预处理器参数。（C 和 Fortran 编译器也会用到）。
* LDFLAGS : 链接器参数。（如：ld ）
