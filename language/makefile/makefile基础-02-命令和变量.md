# 1.命令
每条规则中的命令和操作系统 Shell 的命令行是一致的。 make 的命令默认是被 `/bin/sh` ——UNIX 的标准Shell 解释执行的。除非你特别指定一个其它的 Shell。

# 是注释符
## 1.1 显示命令
make 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用`@`字符在命令行前，那么，
这个命令将不被 make 显示出来:

```make
@echo 正在编译 XXX 模块......
```
当 make 执行时，会输出“正在编译 XXX 模块...”字串，但不会输出命令，如果没有“@”，那
么，make 将输出:

```make
echo 正在编译 XXX 模块......
正在编译 XXX 模块......
```

如果 make 执行时，带入make参数`-n`或`--just-print`，那么其只是**显示命令**，但不会执行命令，这个功能很有利于我们调试我们的 make，看看我们书写的命令是执行起来是什么样子的或是**什么顺序**的。而 make 参数`-s`或 --silent 或 --quiet 则是全面禁止命令的显示。

### 1.2 命令执行
**当依赖目标新于目标时**，也就是当规则的目标需要被更新时，make 会一条一条的执行其后的命令。如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是 cd 命令，你希望第二条命令得在 cd 之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：

```make
# 实例1
exec:
	cd /home/hchen
	pwd

#实例2
exec:
	cd /home/hchen;pwd
```
当我们执行 make exec 时，第一个例子中的 cd 没有作用，pwd 会打印出当前的 make 目录，而第二个例子中，cd 就起作用了，pwd 会打印出“`/home/hchen`”。

### 1.3 命令行出错
mkdir 命令，如果目录存在，那么就出错了。不希望 mkdir 出错而终止规则的运行。

为了做到这一点，忽略命令的出错，我们可以在 make 的命令行前加一个减号`-`（在 Tab 键之后），标记为不管命令出不出错都认为是成功的。如

```make
clean:
	-rm -f *.o
```

一个全局的办法是:make 加上 -i 或是 --ignore-errors 参数,make 中所有命令都会忽略错误。`.IGNORE`作为目标的，那么这个规则中的所有命令将会忽略错误。

make 的参数的是`-k`或是`--keep-going`，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。

### 1.4 嵌套执行make
可以在每个目录中都书写一个该目录的 make，这有利于让我们的 make 变得更加地简洁，而不至于把所有的东西全部写在一个 make 中，这样会很难维护我们的make我们模块编译和分段编译有着非常大的好处。

例如，我们有一个子目录叫 subdir，这个目录下有个 make 文件，来指明了这个目录下文件的编译规则。那么我们总控的 make 可以这样书写：

```make
subsystem:
	cd subdir && $(MAKE)
```
其等价于：

```make
subsystem:
	$(MAKE) -C subdir
```
定义`$(MAKE)`宏变量的意思是，也许我们的 make 需要一些参数，所以定义成一个变量比较利于
维护。这两个例子的意思都是先进入“subdir”目录，然后执行 make 命令。

总控 make 的变量可以传递到下级的 make 中（如果你显示的声明），但是不会覆盖下层的 make 中所定义的变量，除非指定了`-e`参数。

如果你要传递变量到下级 make 中，那么你可以使用这样的声明:

```make
export <variable ...>;

# 实例一
export variable = value
# 等价于
vairbale = value
export variable
```

如果你不想让某些变量传递到下级 make 中，那么你可以这样声明:

```make
unexprot <variable ...>;
```

如果你要**传递所有的变量**，那么，只要一个 export就行了。后面什么也不用跟，表示传递所有的变量。

需要注意的是，有两个变量，一个是SHELL ，一个是`MAKEFLAGS`，这两个变量不管你是否 export，其总是要传递到下层 make 中，特别是 MAKEFLAGS 变量，其中包含了 make 的参数信息，如果我们执行“总控 make”时有 make参数或是在上层 make 中定义了这个变量，那么MAKEFLAGS 变量将会是这些参数，并会传递到下层 make 中，这是一个系统级的环境变量。

但是 make 命令中的有几个参数并不往下传递，它们是`-C` , `-f` , `-h`,`-o`和`-W`（有关 make 参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：

```make
subsystem:
	cd subdir && $(MAKE) MAKEFLAGS=
```

如果你定义了**环境变量 MAKEFLAGS**，那么你得确信其中的选项是大家都会用到的，如果其中有`-t`,`-n`和`-q`参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。

还有一个在“嵌套执行”中比较有用的参数，`-w`或是 `--print-directory`会在 make 的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级 make 目录是“`/home/hchen/gnu/make`”，如果我们使用`make -w`来执行，那么当进入该目录时，我们会看到:

```
make: Entering directory `/home/hchen/gnu/make'.
```
而在完成下层 make 后离开目录时，我们会看到:

```
make: Leaving directory `/home/hchen/gnu/make'
```

当你使用 `-C` 参数来指定 make 下层 make 时，`-w`会被自动打开的。如果参数中有 `-s（--slient）`或是` --no-print-directory `，那么，`-w`总是失效的。

### 1.5定义命令包
如果 make 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义
这种命令序列的语法以 define 开始，以 endef 结束，如:

```make
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
```
还是把这个命令包放到一个示例中来看看吧。

```make
foo.c : foo.y
	$(run-yacc)
```

# 2.变量
在 make 中的定义的变量，就像是 C/C++ 语言中的宏一样，他代表了**一个文本字串**，在 make中执行的时候其会自动原模原样地展开在所使用的地方。在 make 中，变量可以使用在“目标”，“依赖目标”，“命令”或是 make 的其它部分中。

### 2.1 变量基础

变量在声明时需要给予初值，而在使用时，需要给在变量名前加上`$`符号，但最好用小括号`()`或是大括号`{}`把变量给包括起来。

### 2.2  变量中的变量
在 make 中有两种方式来在用变量定义变量的值。

第一种方式，也就是简单的使用 = 号，在 = 左侧是变量，右侧是变量的值，右侧变量的值可以
定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：

```make
foo = $(bar)
bar = $(ugh)
ugh = Huh?
all:
	echo $(foo)
```
执行“make all”将会打出变量`$(foo)`的值是`Huh?`.**变量是可以使用后面的变量来定义的**。

这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：

```make
CFLAGS = $(include_dirs) -O
include_dirs = -Ifoo -Ibar
```
当 CFLAGS 在命令中被展开时，会是`-Ifoo -Ibar -O`。但这种形式也有不好的地方，那就是**递归定义**，如：

```make
CFLAGS = $(CFLAGS) -O
# 或
A = $(B)
B = $(A)
```
这会让 make 陷入无限的变量展开过程中去，当然，我们的 make 是有能力检测这样的定义，并会报错。

为了避免上面的这种方法，我们可以使用 make 中的另一种用变量来定义变量的方法。这种方法使用的是 `:=` 操作符，如：

```make
x := foo
y := $(x) bar
x := later

# 上面等价于
y := foo bar
x := later
```
面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了 make 的函数、条
件表达式和一个系统变量“MAKELEVEL”的使用：

```make
ifeq (0, $(MAKELEVEL))
cur-dir := $(shell pwd)
whoami := $(shell whoami)
host-type := $(shell arch)
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
endif
```
对于系统变量“MAKELEVEL”，其意思是，如果我们
的 make 有一个嵌套执行的动作（参见前面的“嵌套使用 make”），那么，这个变量会记录了我们的当前make 的**调用层数**。

#### 2.2.1两个特殊变量
定义一个变量，其值是一个空格，那么我们可以这样来：

```make
nullstring :=
space := $(nullstring)#end of the line
```
nullstring 是一个 Empty 变量，其中什么也没有，而我们的 space 的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty 变量来标明变量的值开始了，而后面采用“`#`”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。

请注意这里关于“`#`”的使用，注释符“`#`”的这种特性值得我们注意，如果我们这样定义一个变量：

```make
dir := /foo/bar    #directory to put the frobs in
```
dir 这个变量的值是“`/foo/bar`”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“`$(dir)/file`”那么就完蛋了。

还有一个比较有用的操作符是`?=` ，先看示例：

```make
FOO ?= bar
```
其含义是，如果 FOO 没有被定义过，那么变量 FOO 的值就是“bar”，如果 FOO 先前被定义过，
那么这条语将什么也不做，其等价于：

```make
ifeq ($(orign FOO), undefined)
	FOO = bar
endif
```
## 2.3 追加变量
我们可以使用 `+=`操作符给变量追加值

## 2.4 override 指示符
如果有变量是通常 make 的命令行参数设置的，那么 make 中对这个变量的赋值会被忽略。

如果你想在 make 中设置这类参数的值，那么，你可以使用“override”指示符。其语法是

```make
override <variable>; = <value>;
override <variable>; := <value>;
```

## 2.6 环境变量
make 运行时的系统环境变量可以在 make 开始运行时被载入到 make 文件中，但是如果 make中已定义了这个变量，或是这个变量由 make 命令行带入，那么系统的环境变量的值将被覆盖。

如果make 指定了“-e”参数，那么，系统环境变量将覆盖 make 中定义的变量默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 make 传递，则需要使用 exprot 关键字来声明。

## 2.7 变量高级用法
这里介绍两种变量的高级使用方法，**第一种**是变量值的替换。

替换变量中的共有的部分，其格式是`$(var:a=b)`或是`${var:a=b}`，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。

```make
foo := a.o b.o c.o
bar := $(foo:.o=.c)
```
我们先定义了一个`$(foo)`变量，而第二行的意思是把`$(foo)`中所有以`.o`字串“结尾”全部替换成`.c`，所以我们的`$(bar)`的值就是“`a.c b.c c.c`”。

另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：

```make
foo := a.o b.o c.o
bar := $(foo:$.o=%.c)
```
这依赖于被替换字串中的有相同的模式，模式中必须包含一个 % 字符，这个例子同样让 `$(bar)` 变量的值为“a.c b.c c.c”。

**第二种**高级用法是——“把变量的值再当成变量”。先看一个例子：

```make
x = y
y = z
a := $($(x))
```
在这个例子中，`$(x)`的值是“y”，所以`$($(x))` 就是`$(y)`，于是`$(a)`的值就是“z”。（**注意**，是“x=y”，而不是“x=$(y)”）
我们还可以使用更多的层次：

```make
x = y
y = z
z = u
a := $($($(x)))
```

这种技术和“函数”与“条件语句”一同使用的例子：

```make
ifdef do_sort
	func := sort
else
	func := strip
endif

bar := a d b g q c
foo := $($(func) $(bar))
```
这个示例中，如果定义了“do_sort”，那么：`foo := $(sort a d b g q c)`，于是 $(foo) 的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：`foo := $(strip a d b g q c) `，调用的就是strip 函数。

# 3.特殊变量
## 3.1 自动化变量

所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。

下面是所有的自动化变量及其说明：

* `$@`: 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，`$@` 就是匹配于目标中模
式定义的集合。
* `$%` : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是`foo.a(bar.o)`
，那么，`$%`就是 bar.o ，`$@`就是 foo.a 。
* `$<` : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 `%` ）定义的，那么 `$<` 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
* `$?` : 所有比目标新的依赖目标的集合。以空格分隔。
* `$^`: 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除
重复的依赖目标，只保留一份。
* `$+` : 这个变量很像	`$^`，也是所有依赖目标的集合。只是它不去除重复的依赖目标。
*  `$*` : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 `dir/a.foo.b` ，并且目标的模式是`a.%.b` ，那么，`$*` 的值就是`dir/a.foo`。

当你希望只对更新过的依赖文件进行操作时，`$?`在显式规则中很有用，例如，假设有一个函数库文件叫 lib ，其由其它几个 object 文件更新。那么把 object 文件打包的比较有效率的 make 规则是：

```make
lib : foo.o bar.o lose.o win.o
	ar r lib $?
```

在上述所列出来的自动量变量中。四个变量（`$@` 、`$<` 、`$% `、`$*` ）在扩展时只会有一个文件，而另三个的值是一个文件列表。
