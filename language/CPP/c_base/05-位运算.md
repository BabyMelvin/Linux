# 位运算
## 1.信息打印

```c
int a = 0;
printf("%0x\n",a);//16进制
printf("%0X\n",a);//16进制
printf("%d\n",a); //10进制
printf("%o\n",a); //8进制
```

16进制将4位二进制为一位16进制：如 0x25-->0010 0101

8进制将3位二进制为一位8进制：如 o73----->111 101

计算机中数字是以补码的形式存储显示的

正数的原、反、补码都一样。
负数反码保留符号位固定不变，其余位取反
负数的补码反码加一

0的原码跟反码都有两个，因为这里0被分为+0和-0 (0的补码唯一的 0000000)
## 2.位运算符号

位运算操作数必须是整数类型，遵循寻常算术转换.位运算与反码原码无关，只对位进行运算
移位中高位填补方式，可以由算术右移和逻辑右移`-15 >> 2`,软件中是使用补码的形式显示

* `&`:位与运算:特定位清零。位掩码使用.`a&=0xFF;`高位清零,`~0x20`比`0xFFFFFFDF`更受欢迎,可以更好移植性，也方便阅读。
* `|`:位或运算:设定某位
* `^`:位异或运算
* `~`:位NOT运算
* `>>`:位右移运算
* `<<`:位左移运算

## 3.字节对齐

`((size + 7)/8)*8` 保证8字节对齐方法

## 4.LSB & MSB 和 大端小端格式
串口是LSB优先，I2C、1553B是MSB优先，这里(MSB01101011LSB)是指二进制位图.最高有效位0,最低有效位为1.

* 在MSB传输和接收顺序为`01101011`
* 在LSB传输和接收顺序为`11010110`

区别于字节序(通信中，先发送低字节，还是高字节的问题，那叫大端big-endian,小端little-endian)

# 位运算技巧

1.奇偶判断

`a & 1`和`a % 2 == 0`

2.交换两个数:

```c
void swap(int &a, int &b) {
    if(a != b) {
        a ^= b; //a = (a ^ b);
        b ^= a; //b = b^(a^b);^满足交换律 b^(a^b)=b^b^a;数异或自己则为0，与0异或不变，b = a
        a ^= b; // a = b;
    }
}
```

3.变换符号

取反加1 就可以实现`-11`--->`11`变换. `~a + 1`

4.求绝对值

```c
int my_abs(int a) {
    int i = a >> 31;
    return i == 0 ? a : (~a +1);
}
```

再分析，与0异或都会保持不变，与-1即0xFFFFFFF异或相当于取反.因此a 与 i异或后再减i(要么加0 要么减 1)，得到绝对值

```c
int my_abs(int a) {
    int i = a >> 31;
    //未使用任何判断...
    return ((a ^ i) - i);
}
```

# 位操作与空间压缩
要压缩素数表的空间占用使用位操作,下面试筛选素数法计算100以内的素数示例代码:



