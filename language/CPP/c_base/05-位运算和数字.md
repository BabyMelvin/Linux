# 位运算
## 1.信息打印

```c
int a = 10;
long b = 10;
unsigned int c = 30;
float d = 12.3;
printf("%0x\n",a);//16进制
printf("%0X\n",a);//16进制
printf("%#x\n",a);//16进制输出格式为0xa
printf("%#X\n",a);//16进制输出格式为0Xa

printf("输出长整型：%ld", b);
printf("输出定宽格式整型:%10d",a);//10之前会多出8个空格
printf("输出无符号整型:%u",c);//无符号直接使用，避免再进行一个转换
printf("输出浮点型：%f",d);//单精度和双精度都可以使用，默认整数全部输出，小数部分输出6位，超过6位四舍五入
printf("整型浮点数小数长度:%.mf \n", d);//输出实数时小时后保留m位，注意m前面有个点
printf("%d\n",a); //10进制
printf("%o\n",a); //8进制
```

16进制将4位二进制为一位16进制：如 0x25-->0010 0101

8进制将3位二进制为一位8进制：如 o73----->111 101

计算机中数字是以补码的形式存储显示的

正数的原、反、补码都一样。
负数反码保留符号位固定不变，其余位取反
负数的补码反码加一

0的原码跟反码都有两个，因为这里0被分为+0和-0 (0的补码唯一的 0000000)
## 2.位运算符号

位运算操作数必须是整数类型，遵循寻常算术转换.位运算与反码原码无关，只对位进行运算
移位中高位填补方式，可以由算术右移和逻辑右移`-15 >> 2`,软件中是使用补码的形式显示

* `&`:位与运算:特定位清零。位掩码使用.`a&=0xFF;`高位清零,`~0x20`比`0xFFFFFFDF`更受欢迎,可以更好移植性，也方便阅读。
* `|`:位或运算:设定某位
* `^`:位异或运算
* `~`:位NOT运算
* `>>`:位右移运算
* `<<`:位左移运算

## 3.字节对齐

`((size + 7)/8)*8` 保证8字节对齐方法

## 4.LSB & MSB 和 大端小端格式
串口是LSB优先，I2C、1553B是MSB优先，这里(MSB01101011LSB)是指二进制位图.最高有效位0,最低有效位为1.

* 在MSB传输和接收顺序为`01101011`
* 在LSB传输和接收顺序为`11010110`

区别于字节序(通信中，先发送低字节，还是高字节的问题，那叫大端big-endian,小端little-endian)

# 位运算技巧

1.奇偶判断

`a & 1`和`a % 2 == 0`

2.交换两个数:

```c
void swap(int &a, int &b) {
    if(a != b) {
        a ^= b; //a = (a ^ b);
        b ^= a; //b = b^(a^b);^满足交换律 b^(a^b)=b^b^a;数异或自己则为0，与0异或不变，b = a
        a ^= b; // a = b;
    }
}
```

3.变换符号

取反加1 就可以实现`-11`--->`11`变换. `~a + 1`

4.求绝对值

```c
int my_abs(int a) {
    int i = a >> 31;
    return i == 0 ? a : (~a +1);
}
```

再分析，与0异或都会保持不变，与-1即0xFFFFFFF异或相当于取反.因此a 与 i异或后再减i(要么加0 要么减 1)，得到绝对值

```c
int my_abs(int a) {
    int i = a >> 31;
    //未使用任何判断...
    return ((a ^ i) - i);
}
```

# 位运算符用法
## 1.掩码

```
flag &= MASK;
```
例如:flags二进制为1001 0110,MASK二进制位0000 0010。相当于`flags &= 0x02;` flags=0000 0010这个语句将导致flags**除位1外，所有位都被设为0**

## 2.打开位

```
flags |= MASK;
```

例如：flags 二进制为1001 0100 MASK二进制为 0000 0010即：`flags |= 0x02;`，flags-10010110

这个语句将flags中的位设为1，并保留其他所有位不变.

### 2.1 结合移位运算

```
flags |= MASK << n;
```
例如：flags二进制为1001 0110 MASK二进制为 0000 0001 n为4即：

```
flags |= 0x01 <<4;(高电平)
```
flags = 1001 1110
这个语句将flags的位3设为1,并保留其他所有位不变

## 3.清除位(关闭位)

```
flags &= ~MASK;
```
例如：flags二进制为1001 0110 MASK二进制为0000 0010即：`flags &= ~0x02;`，flags = 1001 0100
这个语句将flags**除位1设置为0以外**，**保留其他所有位不变**.

### 3.1 结合位移运算

```
flags &= ~(MASK << n);
```
例如：flags二进制为1001 0110 MASK二进制为0000 00001 n为3即：

```
flags &= ~(0x10 << 3);(低电平)
```
flags = 1001 0010
这个语句将flags的位2设为0，并保留其他所有位不变。

## 4.转置位

```
flags ^= MASK;
```
转置位表示：**如果该位打开**，**则关闭该位**，**如果该位关闭**，则**打开该位**.

例如：flags二进制为1001 0110 MASK二进制为0000 0010即:`flags ^= 0x02;`flags=10010100

## 5.查看一位的值

```
if((flags & MASK) == MASK)
	puts("Wow");
```
例如：flags 二进制为1001 0110 MASK二进制为0000 0010即：

```
if((flags & 0x01) == 0x02)
	puts("Wow");
```
这个语句判断flags位1是否位1，注意优先级。

# 位字段
结构中的 "位字段" 是以 Bit 为单位的， 这已经是计算机的最小单位， 大小是 char 类型的 1/8.  下面的例子中定义的位字段， 分别有 1-4 Bit 大小； 1 Bit 的字段只能放两个数（0、1）， 4 Bit 的字段也只能放下 16 个数：

```c
struct Bit 
{ 
	unsigned a: 1; /* 1 Bit, 取值范围: 0 - 1 */ 
	unsigned b: 2; /* 2 Bit, 取值范围: 0 - 3 */ 
	unsigned c: 3; /* 3 Bit, 取值范围: 0 - 7 */ 
	unsigned d: 4; /* 4 Bit, 取值范围: 0 - 15 */ 
} B; 

int main() 
{ 
    
    B.a = 1; 
    B.b = 3; 
    B.c = 7; 
    B.d = 15; 
    printf("%d, %d, %d, %d/n", B.a, B.b, B.c, B.d); 
    return 0; 
}
```
上例中， 位域的类型被指定为是无符号的整型（unsigned int）， 我试着只要是整型都可以， 但要一致。
假如我们定义 8 个字段， 每个字段都是 1 Bit， 就可以很好地明细一个字节， 譬如：

```
11111111B = 255；
00000001B = 1；
00001111B = 15；
01111111B = 127；
```
下面的例子用程序对上面的说明做了落实：（用 8 个 Bit 构成一个 unsigned char 数）

```
struct Bit { 
	int b8: 1; 
	int b7: 1; 
	int b6: 1; 
	int b5: 1; 
	int b4: 1; 
	int b3: 1; 
	int b2: 1; 
	int b1: 1; 
} B; 
unsigned char *p = NULL;

B.b1 = 1; B.b2 = 1; B.b3 = 1; B.b4 = 1; B.b5 = 1; B.b6 = 1; B.b7 = 1; B.b8 = 1; 
p = (unsigned char *)&B; 
printf("%dn", *p); /* 255 */

B.b1 = 0; B.b2 = 0; B.b3 = 0; B.b4 = 0; B.b5 = 0; B.b6 = 0; B.b7 = 0; B.b8 = 1; 
p = (unsigned char *)&B; 
printf("%dn", *p); /* 1 */

B.b1 = 0; B.b2 = 0; B.b3 = 0; B.b4 = 0; B.b5 = 1; B.b6 = 1; B.b7 = 1; B.b8 = 1; 
p = (unsigned char *)&B; 
printf("%dn", *p); /* 15 */

B.b1 = 0; B.b2 = 1; B.b3 = 1; B.b4 = 1; B.b5 = 1; B.b6 = 1; B.b7 = 1; B.b8 = 1; 
p = (unsigned char *)&B; 
printf("%dn", *p); /* 127 */

getchar(); 
return 0;
```

# 1.一个位域必须存储在同一个字节
一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某**位域从下一单元开始**。例如：

```
struct bs   
{   
  unsigned a:4   
  unsigned :0 /*空域*/   
  unsigned b:4 /*从下一单元开始存放*/   
  unsigned c:4   
}   
```
在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。  

# 2.位域不允许跨两个字节
由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。

# 3.位域可以无位域名
位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：   

```c
struct k   
{   
  int a:1   
  int :2 /*该2位不能使用*/   
  int b:3   
  int c:2   
};   
``` 
从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。