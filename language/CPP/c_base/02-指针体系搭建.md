## 铁律1：指针是一种数据类型

1）	指针也是一种变量，占有内存空间，用来保存内存地址

2）`*p`操作内存

* 在指针声明时，`*`号表示所声明的变量为指针
* 在指针使用时，`*`号表示 操作 指针所指向的内存空间中的值
* `*p`相当于通过地址(p变量的值)找到一块内存；然后操作内存
* `*p`放在等号的左边赋值（给内存赋值）
* `*p`放在等号的右边取值（从内存获取值）

3）指针变量和它指向的内存块是两个不同的概念

4）指针是一种数据类型，是指它指向的内存空间的数据类型
* 含义1：指针步长（p++），根据所致内存空间的数据类型来确定
`p++=-->(unsigned char )p+sizeof(a);`

## 铁律2：间接赋值`（*p）`是指针存在的最大意义 

1）两码事：指针变量和它指向的内存块变量

2）条件反射：指针指向某个变量，就是把某个变量地址否给指针

3）`*p`间接赋值成立条件：3个条件 

* a)2个变量（通常一个实参，一个形参）
* b) 建立关系，实参取地址赋给形参指针 
* c) *p形参去间接修改实参的值 

```c
int iNmu=0;//实参
int *p=NULL;
p = & iNum;
iNum=1;

*p=2;//通过*形参== 简介改变实参的值

```

## 铁律3：理解指针必须和内存四区概念相结合

* 1）	主调函数 被调函数  
	* a)	主调函数可把堆区、栈区、全局数据内存地址传给被调用函数
	* b)	被调用函数只能返回堆区、全局数据
* 2）	内存分配方式
	* a)指针做函数参数，是有输入和输出特性的.


# 指针传递

地址未申请不能进行访问。（**野指针**）

* `*`取地址的内容，野指针不能去内容
* `&`取变量的地址，变量都可取地址

`&`对变量取地址，应该表示将该变量放在这个地址里了。
换句换说，这个地址的内容就是这个变量，那么可以通过`*`操作获得这个地址的内容(即变量)

初始化地址相关的：

* `int a = 0x123A45;`
	* `print a`,a的值是`$a = 76357`,这里是十进制
	* `print &a`,a的地址，`$a = (int *) 0x7fffffffda6c`,地址是64位
	* `print *a;`,**注意**表示取地址0x123A45上的值，会导致非法访问,`Cannot access memory at address 0x12a45`.
* `char *a = NULL`;说明a值为`$1 = (char *)0x0`
	* `print a`,设置为NULL，则地址为`0x0`
	* `print *a`,取a地址的值，非法访问`Cannot access memory at address 0x0`
	* `print &b`,**注意**，这里能够取到地址`$a = (char **) 0x7fffffffda78`

* `char **a = NULL`
	* `print a`:a的值是地址`$a = 0x0`
	* `print *a`:`Cannot access memory at address 0x0`
	* `print **a`:`Cannot access memory at address 0x0`

赋值相关：

赋值就是变量的填充。注意,`*a`如果无法获取那么肯定不能进行填充了啊！！！


## 错误实例1
下面是一个错误的实例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void get_memory(char *p)
{
	p = (char *)malloc(10);
}

void main()
{
	char *str = NULL;
	get_memory(str);
	strcpy(str,"hello world");
	printf("%s\n", str);
	
	if(str)
		free(str);
}
```

分析:

* 1.首先`char *str = NULL`,str的值为0x0.
* 2.调用`get_memory(str)`,相当于`char *p = str`
* 3.`get_memory(str)`并不影响str的值，当`get_memory`返回后str的值仍然为0x0

结论：

strcpy将会导致段错误，因为str为0x0

## 错误实例2

下面是一个错误实例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void get_memory(char **p)
{
	*p = (char *)malloc(10);
}

void main()
{
	char **str = NULL;
	get_memory(str);
	strcpy(str,"hello world");
	printf("%s\n", str);
	
	if(str)
		free(str);
}
```

分析：

* 1.其中`char **str = NULL;`,str的地址为0x0，`*str`0地址未分配，不能进行取值操作。会出现段错误
* 2.所以在`*p`是错误

## 正确版本1

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *get_memory(void)
{
	char *p = NULL;
	p = (char *)malloc(10);
	return p;
}

void main()
{
	char *str = NULL;
	str = get_memory();
	strcpy(str,"hello world");
	printf("%s\n", str);
	
	if(str)
		free(str);
}
```

## 正确版本2

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//这里传入的是 char **p = &str;
void get_memory(char **p)
{
	//*p的地址是可以操作的。因为p = &str;这个地址已经申请了(通过&符号)
	*p = (char *)malloc(10);
}

void main()
{
	char *str = NULL;

	//str变量取地址，能够获得地址值
	get_memory(&str);
	strcpy(str,"hello world");
	printf("%s\n", str);
	
	if(str)
		free(str);
}
```