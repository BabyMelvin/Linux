## 1.数据类型
* “类型”是对数据的抽象
* 类型相同的数据有相同的`表示形式`、`存储格式`以及`相关的操作`
* 程序中使用的所有数据都必定属于某一种数据类型 

<image src="./image/01.png"/>

### 1.1 数据类型的本质

* 数据类型可理解为创建变量的模具（模子）；是`固定内存大小的别名`。
* 数据类型的作用：编译器预算对象（变量）分配的内存空间大小

### 1.2 数据类型的封装(void)

* 1、void的字面意思是“无类型”，`void *`则为“无类型指针”，`void *`可以指向任何类型的数据。
* 2、用法1：数据类型的封装`int InitHardEnv(void **handle);`, 典型的如内存操作函数memcpy和memset的函数原型分别为`void * memcpy(void *dest, const void *src, size_t len);`和`void * memset ( void * buffer, int c, size_t num );`
* 3、用法2：  void修饰函数返回值和参数，仅表示无。如果函数没有返回值，那么应该将其声明为void型如果函数没有参数，应该声明其参数为void.

```c
int function(void){return 1;}
```
* 4、void指针的意义
	*  C语言规定只有`相同类型的指针`才可以相互赋值
	* `void*`指针作为左值用于“接收”任意类型的指针
	* `void*`指针作为右值赋值给其它指针时需要强制类型转换

```c
int  *p1=NULL;
char *p2=(char*)malloc(sizeof(char)*20);
```

* 5、**不存在void类型的变量**.C语言没有定义`void`究竟是多大内存的别名.
* 6、扩展阅读`《void类型详解.doc》`

### 1.3数据类型总结与扩展
* 1、数据类型本质是固定内存大小的别名；是个模具，c语言规定：通过数据类型定义变量。
* 2、数据类型大小计算（`sizeof`）
* 3、可以给已存在的数据类型起别名`typedef`
* 4、数据类型封装概念（void 万能类型）

## 2.变量

* 概念:既能读又能写的内存对象，称为变量；若一旦初始化后不能修改的对象则称为常量。
* 变量定义形式：`类型  标识符, 标识符, … , 标识符;` 

### 2.1 变量的本质

* 1.程序通过变量来申请和命名内存空间 `int a = 0`
* 2.通过变量名访问内存空间,（一段连续）内存空间的别名（是一个门牌号） 
* 3.修改变量有几种方法？
	* 直接
	* 间接。内存有地址编号，拿到地址编号也可以修改内存；
* 4.数据类型和变量的关系.通过数据类型定义变量

### 2.2程序的内存四区模型

<image src="./image/02.png"/>

流程说明:

* 1、操作系统把物理硬盘代码load到内存
* 2、操作系统把c代码分成四个区
* 3、操作系统找到main函数入口执行

各区元素分析

|位置     |说明|
|-------|--|
|栈区(stack)|由编译器自动分配释放，存放函数的参数值，局部变量的值等。|
|堆区(heap)|一般程序员分配(动态内存申请与释放)，若不主动释放，程序结束由系统回收。|
|全局区(静态区)(static)|全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化全局变量和未初始化的静态变量在相邻的另一个块区域，该区域在程序结束后由系统释放|
|常量区|字符串常量和其他常量的存储位置，程序结束后由操作系统释放|
|程序代码区|存放函数体的二进制代码|

### 2.3函数调用模型

<image src="./image/03.png"/>

<image src="./image/04.png"/>

### 2.4 内存四区模型和函数调用模型变量传递分析

* 1、一个主程序有n函数组成，c++编译器会建立有几个堆区？有几个栈区？
* 2、函数嵌套调用时，实参地址传给形参后，C++编译器如何管理变量的生命周期？
分析：函数A，调用函数B，通过参数传递的变量（内存空间能用吗？）

<image src="./image/05.png"/>

注意：函数参数的传递通过中间变量传递，返回原函数也会产生一个中间变量。为什么栈变量释放，也不会对原变量影响的原因
