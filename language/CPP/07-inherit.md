## 继承和派生
面向对象程序设计有4个主要特点：抽象、封装、继承和多态性。派生类定义语法形式:
```cpp
class 派生类名：基类名表
{
	数据成员和成员函数声明
};

基类名表 构成
	访问控制 基类名，访问控制 基类名，。。。
```
C++中的继承方式（public、private、protected）会影响子类的对外访问属性判断某一句话，能否被访问

* 1）看调用语句，这句话写在子类的内部、外部
* 2）看子类如何从父类继承（public、private、protected）
* 3）看父类中的访问级别（public、private、protected）

### 1.继承中的构造和析构
#### 1.1 类型兼容性原则
类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。即，通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。

* 子类对象可以当作父类对象使用
* 子类对象可以直接赋值给父类对象
* 子类对象可以直接初始化父类对象
* 父类指针可以直接指向子类对象
* 父类引用可以直接引用子类对象

#### 1.2 继承中构造和析构 

* 在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化
* 在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理

继承中的构造析构调用原则

* 1、子类对象在创建时会首先调用父类的构造函数
* 2、父类构造函数执行结束后，执行子类的构造函数
* 3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用
* 4、析构函数调用的先后顺序与构造函数相反

继承与组合混搭情况下，构造和析构调用原则 

* 先构造父类，再构造成员变量、最后构造自己
* 先析构自己，在析构成员变量、最后析构父类

继承中的同名成员变量处理方法

* 1.当子类成员变量与父类成员变量同名时，子类依然从父类继承同名成员
* 2.**NOTE**在子类中通过作用域分辨符::进行同名成员区分（在派生类中使用基类的同名成员，显式地使用类名限定符） 
* 3.同名成员存储在内存中的不同位置

* 基类成员的作用域延伸到所有派生类
* 派生类的重名成员屏蔽基类的同名成员
* 派生类屏蔽基类同名成员函数调用自身的成员函数

#### 1.3 派生中的static关键字

* 基类定义的静态成员，将被所有派生类共享
* 根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质 （遵守派生类的访问控制）
* 派生类中访问静态成员，用以下形式显式说明：`类名 :: 成员`或通过对象访问`对象名 . 成员`

### 2 多继承
#### 2.1 多继承概念

* 一个类有多个直接基类的继承关系称为多继承
*  多继承声明语法

```cpp
class 派生类：访问控制权限 基类名1，访问控制 基类名2
{
	数据成员和成员函数声明
};
```

多继承的派生类构造和访问 

* 1.多个基类的派生类构造函数可以用初始式调用基类构造函数初始化数据成员
* 2.执行顺序与单继承构造函数情况类似。多个直接基类构造函数执行顺序取决于定义派生类时指定的各个继承基类的顺序。
* 3.一个派生类对象拥有多个直接或间接基类的成员。不同名成员访问不会出现二义性。如果不同的基类有同名成员，派生类对象访问时应该加以识别。 

#### 2.2 虚继承
如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性

总结:

* 如果一个派生类从多个基类派生，而这些基类又有一个共同
 的基类，则在对该基类中声明的名字进行访问时，可能产生二义性
*  如果在多条继承路径上有一个公共的基类，那么在继承路径的某处
 汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象
* 要使这个公共基类在派生类中只产生一个子对象，必须对这个基类
声明为虚继承，使这个基类成为虚基类。
*  虚继承声明使用关键字`virtual`

#### 2.3 继承总结 

* 继承是面向对象程序设计实现软件重用的重要方法。程序员可以在已有基类的基础上定义新的派生类。
* 单继承的派生类只有一个基类。多继承的派生类有多个基类。
* 派生类对基类成员的访问由继承方式和成员性质决定。
* 创建派生类对象时，先调用基类构造函数初始化派生类中的基类成员。调用析构函数的次序和调用构造函数的次序相反。
* C++提供虚继承机制，防止类继承关系中成员访问的二义性。
* 多继承提供了软件重用的强大功能，也增加了程序的复杂性。