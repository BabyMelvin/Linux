## 三 复制控制
### 3.1 复制构造函数
#### 1.1 几个要点
#### (1) 复制构造函数
  复制构造函数是一种特殊构造函数，只有1个形参，该形参（常用 const &修饰）是对该类类型的引用。
```c
class Peopel
	{
	public:
	     Peopel();//默认构造函数
	     Peopel(const Peopel&);//复制构造函数
	     ~Peopel();//析构函数
	};
```
* 当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。`Peopel a1; Peopel a2 = a1;`
* 当将该类型的对象传递给函数或函数返回该类型的对象时，将隐式使用复制构造函数.`Peopel Func(Peopel b){...}`
#### (2)析构函数
 * 析构函数是构造函数的互补：当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。
 * 析构函数可用于释放构造对象时或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非` static` 数据成员的析构函数。
#### (3) 复制控制
 复制构造函数、赋值操作符和析构函数总称为复制控制。编译器自动实现这些操作，但类也可以定义自己的版本。
#### (4) 两种初始化形式
C++ 支持两种初始化形式：直接初始化和复制初始化。直接初始化将初始化式放在圆括号中，复制初始化使用` = `符号。
 * 对于内置类型，例如int, double等，直接初始化和复制初始化没有区别。
 *  对于类类型：直接初始化直接调用与实参匹配的构造函数；复制初始化先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象。直接初始化比复制初始化更快。
#### (5)形参和返回值
 当形参或返回值为类类型时，由该类的复制构造函数进行复制。 
#### (6)初始化容器元素
 复制构造函数可用于初始化顺序容器中的元素。例如：
`vector<string> svec(5);`
  编译器首先使用 string 默认构造函数创建一个临时值，然后使用复制构造函数将临时值复制到 svec 的每个元素。 
#### (7)构造函数与数组元素
* 如果没有为类类型数组提供元素初始化式，则将用默认构造函数初始化每个元素.
```c
Sales_item primer_eds[] = { string("0-201-16487-6"),
                                 string("0-201-54848-8"),
                                 string("0-201-82470-1"),
                                 Sales_item()
                               };
```
#### 1.2 合成的复制构造函数
#### (1)合成的复制构造函数
 如果没有定义复制构造函数，编译器就会为我们合成一个。合成复制构造函数的行为是，执行逐个成员初始化，将新对象初始化为原对象的副本。
逐个成员初始化：合成复制构造函数直接复制内置类型成员的值，类类型成员使用该类的复制构造函数进行复制。
例外：如果一个类具有数组成员，则合成复制构造函数将复制数组。复制数组时合成复制构造函数将复制数组的每一个元素。

#### 1.3 定义自己的复制构造函数
#### (1) 只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义复制构造函数，也可以复制。 
```c
class Peopel
	{
	public:
	     std::string name;
	     unsigned int id;
	     unsigned int age;
	     std::string address;
	};
```
	
### (2) 有些类必须对复制对象时发生的事情加以控制。
  例如，类有一个数据成员是指针，或者有成员表示在构造函数中分配的其他资源。而另一些类在创建新对象时必须做一些特定工作。这两种情况下，都必须定义自己的复制构造函数。最好显式或隐式定义默认构造函数和复制构造函数。如果定义了复制构造函数，必须定义默认构造函数。
 
#### 1.4 禁止复制
  有些类需要完全禁止复制。例如，iostream 类就不允许复制。延伸：容器内元素不能为iostream 为了防止复制，类必须显式声明其复制构造函数为 private。

### 2 赋值操作符
 与复制构造函数一样，如果类没有定义自己的赋值操作符，则编译器会合成一个。
(1)重载赋值操作符
Sales_item& operator=(const Sales_item &);
(2)合成赋值操作符
     合成赋值操作符会逐个成员赋值：右操作数对象的每个成员赋值给左操作数对象的对应成员。除数组之外，每个成员用所属类型的常规方式进行赋值。对于数组，给每个数组元素赋值。
(3)复制和赋值常一起使用 
     一般而言，如果类需要复制构造函数，它也会需要赋值操作符。 

### 3 析构函数
  构造函数的用途之一是自动获取资源；与之相对的是，析构函数的用途之一是回收资源。除此之外，析构函数可以执行任意类设计者希望在该类对象的使用完毕之后执行的操作。
#### (1) 何时调用析构函数
    
   * 撤销（销毁）类对象时会自动调用析构函数。
   * 变量（类对象）在超出作用域时应该自动撤销（销毁）
   * 动态分配的对象(new A)只有在指向该对象的指针被删除时才撤销（销毁）。
   * 撤销（销毁）一个容器（不管是标准库容器还是内置数组）时，也会运行容器中的类类型元素的析构函数（容器中的元素总是从后往前撤销）。

#### (2)何时编写显式析构函数
  如果类需要定义析构函数，则它也需要定义赋值操作符和复制构造函数，这个规则常称为三法则：如果类需要析构函数，则需要所有这三个复制控制成员。
### (3)合成析构函数
 合成析构函数按对象创建时的逆序撤销每个非 static 成员，因此，它按成员在类中声明次序的逆序撤销成员。 对于每个类类型的成员，合成析构函数调用该成员的析构函数来撤销对象。合成析构函数并不删除指针成员所指向的对象。 所以，如果有指针成员，一定要定义自己的析构函数来删除指针.析构函数与复制构造函数或赋值操作符之间的一个重要区别：即使我们编写了自己的析构函数，合成析构函数仍然运行。
 

## 四 友元
* 友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类。
* 友元可以出现在类定义的内部的任何地方。
*  友元不是授予友元关系的那个类的成员，所以它们不受声明出现部分的访问控制影响。
* 建议：将友元声明成组地放在类定义的开始或结尾。
 