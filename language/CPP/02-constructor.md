## 二 构造函数
 构造函数是特殊的成员函数，用来保证每个对象的数据成员具有合适的初始值。构造函数名字与类名相同，不能指定返回类型（也不能定义返回类型为void），可以有`0-n`个形参。 在创建类的对象时，编译器就运行一个构造函数。
 
### 1 构造函数可以重载
可以为一个类声明的构造函数的数量没有限制，只要每个构造函数的形参表是唯一的。
```c
class Sales_item;
	{
	public: 
	     Sales_item(const std::string&); 
	     Sales_item(std::istream&); 
	     Sales_item(); //默认构造函数
	}; 
```
### 2 构造函数自动执行 
 只要创建该类型的一个对象，编译器就运行一个构造函数：
```c
Sales_item item1("0-201-54848-8");
Sales_item *p = new Sales_item(); 
```
 第一种情况下，运行接受一个 `string `实参的构造函数，来初始化变量`item1`。
 第二种情况下，动态分配一个新的` Sales_item `对象，通过运行默认构造函数初始化该对象。
 
### 3 构造函数初始化式
与其他函数一样，构造函数具有名字、形参表和函数体。
与其他函数不同的是，构造函数可以包含一个构造函数初始化列表：  
```c
Sales_item::Sales_item(const string &book): isbn(book), units_sold(0), revenue(0.0)
{ } 
```
* 构造函数初始化列表以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个数据成员后面跟一个放在圆括号中的初始化式。
* 构造函数可以定义在类的内部或外部。构造函数初始化只在构造函数的定义中指定。
*  构造函数分两个阶段执行：(1)初始化阶段；(2)普通的计算阶段。初始化列表属于初始化阶段(1)，构造函数函数体中的所有语句属于计算阶段(2).
*  初始化列表比构造函数体先执行。不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。
### 3.1 哪种类需要初始化式
 const 对象或引用类型的对象，可以初始化，但不能对它们赋值，而且在开始执行构造函数的函数体之前要完成初始化。 初始化 const 或引用类型数据成员的唯一机会是构造函数初始化列表中，在构造函数函数体中对它们赋值不起作用。没有默认构造函数的类类型的成员，以及 const 或引用类型的成员，必须在初始化列表中完成初始化。
 
```c
	class ConstRef 
	{ 
	public: 
	     ConstRef(int ii); 
	private: 
	     int i; 
	     const int ci; 
	     int &ri; 
	}; 
	ConstRef::ConstRef(int ii) 
	{
	     i = ii;   // ok 
	     ci = ii;  // error
	     ri = i;   // 
	}
```
应该这么初始化：`ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { } `
### 3.2 成员初始化的次序
 每个成员在构造函数初始化列表中只能指定一次。重复初始化，编译器一般会有提示。 成员被初始化的次序就是定义成员的次序，跟初始化列表中的顺序无关。
### 3.3 初始化式表达式
  初始化式可以是任意表达式
```c
Sales_item(const std::string &book, int cnt, double price): isbn(book), units_sold(cnt), revenue(cnt * price) { }
```

#### 3.4 类类型的数据成员的初始化式
  初始化类类型的成员时，要指定实参并传递给成员类型的一个构造函数，可以使用该类型的任意构造函数。
`Sales_item(): isbn(10, '9'), units_sold(0), revenue(0.0) {}`
#### 3.5 类对象的数据成员的初始化      
 在类A的构造函数初始化列表中没有显式提及的每个成员，使用与初始化变量相同的规则来进行初始化。类类型的数据成员，运行该类型的默认构造函数来初始化。

```c
class A
	{
	    public:
	        int ia;
	        B b;
	};
```
A类对象`A a;`不管a在局部作用域还是全局作用域，b使用B类的默认构造函数来初始化，ia的初始化取决于a的作用域，a在局部作用域，ia不被初始化，a在全局作用域，ia初始化0。

### 4 默认构造函数 
不含形参的构造函数就是默认构造函数。     只要定义一个对象时没有提供初始化式，就使用默认构造函数。如：` A a;`为所有形参提供默认实参的构造函数也定义了默认构造函数。例如：
```c
class A
	{
	public: 
	     A(int a=1,char c =''){}
	private:  
	     int ia;
	     char c1;
	};
```
### 4.1 合成的默认构造函数
 只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。一个类只要定义了一个构造函数，编译器也不会再生成默认构造函数。
建议：

* 如果定义了其他构造函数，也提供一个默认构造函数。
*  如果类包含内置或复合类型（如 int& 或 string*）的成员，它应该定义自己的构造函数来初始化这些成员。每个构造函数应该为每个内置或复合类型的成员提供初始化。
 
### 5 隐式类类型转换
#### 5.1 只含单个形参的构造函数能够实现从形参类型到该类类型的一个隐式转换
```c
class A
	{
	public:
	     A(int a)
	     {
	          ia =a;
	     }
	 
	     bool EqualTo(const A& a)
	     {
	          return ia == a.ia;
	     }
	 
	private:
	     int ia;
	};
	 
	A a(1);
	bool bEq = false;
	bEq = a.EqualTo(1);//参数为1，实现从int型到A的隐式转换
```
	
 
#### 5.2抑制由构造函数定义的隐式转换
  通过将构造函数声明为 explicit，来防止在需要隐式转换的上下文中使用构造函数： 
```c
class A
	{
	public:
	     explicit A(int a )
	     {
	          ia =a;
	     }
	 
	     bool EqualTo(const A& a)
	     {
	          return ia == a.ia;
	     }
	 
	private:
	     int ia;
	};
```  
通常，除非有明显的理由想要定义隐式转换，否则，单形参构造函数应该为 `explicit`。将构造函数设置为 `explicit `可以避免错误。