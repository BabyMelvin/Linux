# 1.词法陷阱

* 1.`=`和`==`不同
* 2.`&`和`|`不同于`&&`和`||`
* 3.贪心写法`3/*p`问题
* 4.整型常量：
	* 整型常量第一个字符为0，表示八进制数
	* 注意有时候为了格式对齐，**无意写成八进制数**：

```c
struct {
	int part_number;
	cahr *descrptionion;
} partab[] = {
	046 , "left handed widget",
	047 , "right handed widget",
	125 , "fammis"
};
```
* 5.字符与字符串：C语言中单引号和双引号含义不同。
	* 单引号实际代表一个整数，整数值对应该字符在编译器采用的字符集的序列号。`'a'`:含义为0141(八进制)或者97(十进制)
	* 双引号表示字符串：代表指向一个**无名数组起始数组起始字符的指针**。该数组被双引号之间的字符以及一个额外的二进制值为零的字符`\0`初始化。

```c
printf("Hello world\n");
//与下面等效
char hello[] = {'H','e','l','l','o','w','o','r','l','d','\n',0};
printf(hello);
```

整型数(一个16或者32位)的存储空间可以容纳多个字符(一般为8位)，因此有的C编译器允许在一个字符常量(以及字符串常量)中包含多个字符。也就是用`'yes'`代替`"yes"`不会被该编译器检测到(gcc有警告)。

* 后者`"yes"`的含义表示：`'y','e','s','\0'`的字符。
* 前者`'yes'`含义表示：一个整数值，代表的数值按照特定编译器实现中定义方式组合得到。

注意：Borlandc++v5.5和LCCv3.6做法是，忽略多余的字符，最后的整数值对应第一个字符的整数值，而Visual c++6.0和GCCv2.95中采用的做法是，依次用后一个字符覆盖前一个字符，最后得到的数值即最后一个字符的整数值。

# 2.语法陷阱


## 2.1.理解函数声明
一条简单规则：按照使用的方式来声明

任何C变量的声明都由两部分组成：类型以及一组类似表达式的声明符(declarator)。声明中给定类型的结果。

* 1.最简单的单个变量
	* `float f,g;`表达式f和g的类型为浮点整数(float)
	* `float((f))`声明符合表达式相似，所以可以在声明符中任意使用括号。当对齐求值时，`((f))`为浮点类型，由此推知，f也是浮点类型
* 2.函数和指针类型声明
	* `float ff()`::`ff()`返回值为浮点类型的函数。
	* `float *pf`:`*pf`是一个浮点数，pf是一个指向浮点数的指针
	* `float *g(), (*h)()`：表示`*g()`和`(*h)()`是浮点表达式。因为`()`结合优先级高于`*`,`*g()`也就是*(g())：g是一个函数，函数返回值类型为指向浮点数的指针。同理得出h是一个函数指针，h所指向函数的返回值为浮点数。

分析表达式`(*(void(*)())0)()`,两步来分析：

* 1.fp是一个函数指针，调用方式`(*fp)()`，fp该指针所指向的函数，`(*fp)()`就是调用该函数的方式。ANSI C标准允许程序员将上式简写为`fp()`，这只是一种**简写的方式**.表达式`(*fp)()`，`*fp`两侧的括号非常重要，因为函数运算符`()`优先级高于单目运算符`*`。如果`*fp`两侧没有括号，那么`*fp()`实际上与`*(fp())`的含义完全一致，ANSI C把它作为`*((*fp)())`的简写形式。
* 2.`(*0)()`上式并不能生效，因为预算符*必须要一个指针来做操作数。而且这个指针还应该是一个函数指针，这样经过运算符`*`作用后的结果才能被作为函数调用。因此，上式中必须对0作类型转换，转换后的类型可以大致描述为：指向返回值为void类型的函数的指针。

如果一个指向返回值void类型的函数指针，那么`(*fp)()`的值为void，fp的声明如下：`void (*fp)();`，因此我们可以用下式完成调用存储位置为0的子例程：

```
void (*fp)();
(*fp)();
```

但是我们一旦知道如何声明一个变量，自然知道如何对一个常数进行类型转换，将其转型为该变量的类型：**只需要在变量声明中将变量名去掉即可**。

因此，将常数0转换为"指向返回值为void的函数的指针"类型，可以这样写：`((void(*)0))()`.我们可以用`(void(*)())0`来替换fp,从而得到：`(*(void(*)())0)()；`末尾的分号使得表达式成为一个语句。

使用typedef语句能够表达的更清晰：

```c
typdef void(*funcptr)();
(*(funcptr)0){};
```


还有一些signal库函数：接收两个参数：一个代表需要"被捕获"的特定signal整数值；另一个指向用户提供的函数指针，该函数用于处理"捕获到"的特定signal，返回值类型为void。

signal函数是如何声明的？

1.定义一个信号处理函数：

```c
//函数声明
void sigfunc(int);
void sigfunc(int n) {
	/*特定信号处理部分*/
}
```
声明一个指向sigfunc**函数的指针变量**，设置sfp指向sigfunc函数，`*sfp`就代表sigfunc函数，因此`*sfp`可以被调用。因此声明sfp:`void (*sfp)(int);`

因为signal函数的返回值类型与sfp返回类型一样，上式也就声明为signal函数，我们可以声明如下signal函数：

`void(*signal(something))(int);`
此处something代表了signal函数的参数类型，可以理解：传递适当的参数以调用signal函数，对signal函数返回值(为函数指针类型)解除引用(dereference)，然后传递一个整型参数调用解除引用后所得函数，最后返回void类型。因此,signal函数的返回值是一个指向返回值为void类型的函数指针。

signal函数声明如下：

```c
//返回类型为void (*)(int);
void(*signal(int,void(*)(int))(int);
```

同样地，使用typedef可以简化声明函数声明：

```c
typdef void(*HANDLER)(int);
HANDLER signal(int,HANDLER);
```

## 2.2 运算优先级
1.常量FLAG是一个整数，某位为1，可以判断整型变量flags在常量FLAG为1的那一位是否同样为1：

`if(flags&FLAG){}`,如果增加可读性`if(flags & FLAG !=0)`导致错误，因为**!=运算优先级高于&运算**实际执行为`if(flags & (FLAG!=0))`

2.hi和low两个整数，值介于0到15，如果r是一个8位整数，且r的低4位于low各位上的数一致，高4位于hi各位一致，很自然想到这样写`r = hi << 4 + low`，**加法的优先级高于位移优先级**，本利相当于`r = hi << （4 + low）`

两种方法改进：

```c
r = (hi << 4) + low;
r = hi << 4 | low;
```

## 2.3 语句结束标志分号
多写一个分号，一般作为一个空语句。if情形需要注意。

```c
//1.相当于只执行big = x[i]；
if(x[i] > big);
	big = x[i];

//2.少些分号,相当于return logrec.date =x[0];
if (n < 3)
	return
logrec.date = x[0];
```

## 2.4 switch语句
注意break情形

## 2.5 函数调用
c语言要求：在函数调用即使函数不带参数，也应该包括参数列表。因此f是一个函数`f();`是一个函数调用语句，而`f;`却是一个什么也不做的语句。更确切，计算函数f的地址，却并不调用该函数。

## 2.6 “悬挂”else引发的问题

```c
if (x == 0)
	if (y==0) error();
else {
	z = x + y;
	f(&z);
}
```
实际的逻辑执行为：

```c
if(x == 0){
	if(y == 0)
		error();
	else {
		z = x + y;
		f(&z);
	}
}
```
如果得到原来想要的意图，结果应该写为：

```c
if (x == 0) {
	if(y == 0)
		error();
} else {
	z = z + y;
	f(&z);
}
```

# 3.语义“陷阱”
## 3.1 指针与数组
C语言中的数组注意以下两点：

1.C语言中**只有一维数组**，而且数组的大小必须在编译期就作为一个常数确定下来，然而，C语言中的数组元素可以是任何类型的对象，当然也可以是另外一个数组。“仿真”出一个多维数组不是难事。

2.一个数组，只能够做两件事：确定该数组的大小，以及获得指向该数组下标为0的元素的指针。 其他有关数组的操作，乍看上去以数组下标进行运算的，实际上都是通过指针进行的。换句话说，任何一个数组下标运算都等同于一个对应的指针运算，因此我们完全可以依据指针行为为定义数组下标的行为。

`int calendar[12][13];`声明一个calendar数组，该数组拥有12个数组类型的元素，其中每个元素都是一个拥有31个整型元素的数组。因此`sizeof(calendar)`的值是`(12x31)xsizeof(int)`。如果calendar不是用于sizeof操作数,其他场合，那么calendar总是被转换成一个指向calendar数组的起始元素的指针。

**任何指针都是指向某种类型的变量**。`int* ip;`表明ip是一个指向整型变量的指针。

a为一个拥有3个整型元素的数组。如果我们该出现指针地方，却采用数组名来代替，那么数组名就被作为指向该数组下标为0的元素的指针。因此我们可以这样写`p = a;`;就会把数组a中下标为0的元素地址赋值给p