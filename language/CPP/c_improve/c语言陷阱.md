# 1.词法陷阱

* 1.`=`和`==`不同
* 2.`&`和`|`不同于`&&`和`||`
* 3.贪心写法`3/*p`问题
* 4.整型常量：
	* 整型常量第一个字符为0，表示八进制数
	* 注意有时候为了格式对齐，**无意写成八进制数**：

```c
struct {
	int part_number;
	cahr *descrptionion;
} partab[] = {
	046 , "left handed widget",
	047 , "right handed widget",
	125 , "fammis"
};
```
* 5.字符与字符串：C语言中单引号和双引号含义不同。
	* 单引号实际代表一个整数，整数值对应该字符在编译器采用的字符集的序列号。`'a'`:含义为0141(八进制)或者97(十进制)
	* 双引号表示字符串：代表指向一个**无名数组起始数组起始字符的指针**。该数组被双引号之间的字符以及一个额外的二进制值为零的字符`\0`初始化。

```c
printf("Hello world\n");
//与下面等效
char hello[] = {'H','e','l','l','o','w','o','r','l','d','\n',0};
printf(hello);
```

整型数(一个16或者32位)的存储空间可以容纳多个字符(一般为8位)，因此有的C编译器允许在一个字符常量(以及字符串常量)中包含多个字符。也就是用`'yes'`代替`"yes"`不会被该编译器检测到(gcc有警告)。

* 后者`"yes"`的含义表示：`'y','e','s','\0'`的字符。
* 前者`'yes'`含义表示：一个整数值，代表的数值按照特定编译器实现中定义方式组合得到。

注意：Borlandc++v5.5和LCCv3.6做法是，忽略多余的字符，最后的整数值对应第一个字符的整数值，而Visual c++6.0和GCCv2.95中采用的做法是，依次用后一个字符覆盖前一个字符，最后得到的数值即最后一个字符的整数值。

# 2.语法陷阱


## 2.1.理解函数声明
一条简单规则：按照使用的方式来声明

任何C变量的声明都由两部分组成：类型以及一组类似表达式的声明符(declarator)。声明中给定类型的结果。

* 1.最简单的单个变量
	* `float f,g;`表达式f和g的类型为浮点整数(float)
	* `float((f))`声明符合表达式相似，所以可以在声明符中任意使用括号。当对齐求值时，`((f))`为浮点类型，由此推知，f也是浮点类型
* 2.函数和指针类型声明
	* `float ff()`::`ff()`返回值为浮点类型的函数。
	* `float *pf`:`*pf`是一个浮点数，pf是一个指向浮点数的指针
	* `float *g(), (*h)()`：表示`*g()`和`(*h)()`是浮点表达式。因为`()`结合优先级高于`*`,`*g()`也就是*(g())：g是一个函数，函数返回值类型为指向浮点数的指针。同理得出h是一个函数指针，h所指向函数的返回值为浮点数。

分析表达式`(*(void(*)())0)()`,两步来分析：

* 1.fp是一个函数指针，调用方式`(*fp)()`，fp该指针所指向的函数，`(*fp)()`就是调用该函数的方式。ANSI C标准允许程序员将上式简写为`fp()`，这只是一种**简写的方式**.表达式`(*fp)()`，`*fp`两侧的括号非常重要，因为函数运算符`()`优先级高于单目运算符`*`。如果`*fp`两侧没有括号，那么`*fp()`实际上与`*(fp())`的含义完全一致，ANSI C把它作为`*((*fp)())`的简写形式。
* 2.`(*0)()`上式并不能生效，因为预算符*必须要一个指针来做操作数。而且这个指针还应该是一个函数指针，这样经过运算符`*`作用后的结果才能被作为函数调用。因此，上式中必须对0作类型转换，转换后的类型可以大致描述为：指向返回值为void类型的函数的指针。

如果一个指向返回值void类型的函数指针，那么`(*fp)()`的值为void，fp的声明如下：`void (*fp)();`，因此我们可以用下式完成调用存储位置为0的子例程：

```
void (*fp)();
(*fp)();
```

但是我们一旦知道如何声明一个变量，自然知道如何对一个常数进行类型转换，