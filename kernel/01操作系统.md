## 操作系统概述
### 操作系统目标功能
* 操作系统是控制应用程序执行的程序，并充当应用程序和计算机硬件之间的接口。它有下面三个目标：
	* 方便：操作系统使计算机更易于使用。
	* 有效：操作系统允许以更有效的方式使用计算机系统资源。
	* 扩展的能力：在构造操作系统时，应该允许在不妨碍服务的前提下有效地开发、测试和引进新的系统功能。
	
### 用户/计算机接口

操作系统通常提供了以下几个方面的服务：
	
* `程序开发`：操作系统提供各种各样的工具和服务，如编辑器和调试器，用于帮助程序员开发程序。通常，这些服务以实用工具程序的形式出现，严格来说并不属于操作系统核心的一部分；它们由操作系统提供，称为应用程序开发工具。
* `程序运行`：运行一个程序需要很多步骤。必须把指令和数据载入到主存储器、初始化I/O设备、准备其他一些资源。操作系统为用户处理这些调度问题。
* `I/O设备访问`：每个I/O设备的操作都需要自己特有的指令集或控制信号，操作系统隐藏这些细节，并提供统一的接口，因此程序员可以使用简单的读和写操作来访问这些设备。
* `文件访问控制`：对操作系统而言，关于文件的控制不仅必须详细了解I／O设备(磁盘驱动器、磁带驱动器)的特性，而且必须详细了解存储介质中文件数据的结构。此外，对有多个用户的系统，操作系统还可以提供保护机制来控制对文件的访问。
* `系统访问`：对于共享或公共系统，操作系统控制对整个系统的访问以及对某个特殊系统资源的访问。访问功能模块必须提供对资源和数据的保护，以避免未授权用户的访问，还必须解决资源竞争时的冲突问题。
* `错误检测和响应`：计算机系统运行时可能发生各种各样的错误，包括内部和外部硬件错误，如存储器错误、设备失败或故障，以及各种软件错误，如算术溢出、试图访问被禁止的，存储器单元、操作系统无法确认应用程序的请求等。
* `审计`：一个好的操作系统可以收集对各种资源的审计，监控诸如响应时间之类的性能参数。
<center>
<image src="./image/01-7.png">
</center>

### 资源管理器的操作系统
> 一台计算机就是一组资源，这些资源用于对数据的移动、存储和处理以及对这些功能的控制。而操作系统负责管理这些资源。

* 操作系统与普通的计算机软件作用相同，也就是说，它是由处理器执行的一段程序或一组程序。
* 操作系统经常会释放控制，而且必须`依赖处理器`才能恢复控制。
* **操作系统实际上不过是一组计算机程序**，与其他计算机程序类似，它们都给处理器提供指令，主要区别在于程序的意图。
	* 操作系统控制处理器使用其他系统资源，并控制处理器运行其他程序的时间安排。
	* 但是，处理器为了做任何一件这类事情，都必须停止执行操作系统程序，而去执行其他程序。因此，这时操作系统释放对处理器的控制，让处理器去做其他一些有用的工作，然后用足够长的时间恢复控制，让处理器准备好做下一件工作。
* 操作系统有一部分在主存中，其中包括内核程序(kernel或nucleus)和当前正在使用的其他操作系统程序，内核程序包含操作系统中最常使用的功能。主存的其余部分包含其他用户程序和数据。
* 资源(主存)的分配由操作系统和处理器中的存储管理硬件联合控制。
* 操作系统决定在程序运行过程中何时使用I/O设备，并控制文件的访问和使用。
* 处理器自身也是一个资源，操作系统必须决定在运行一个特定的用户程序时，可以分配多少处理器时间。在多处理器系统中，这个决定要传到所有的处理器。
<center>
<image src="./image//01-8.png">
01-8 操作系统作为资源管理器
</center>

### 操作系统易扩展
* 操作系统不断发展，主要满足硬件和软件需求。纠错能力不断增强。
* 操作系统发展
	* 串行处理：没有操作系统概念。问题->调度和准备时间
	* 简单批处理系统：监控软件。
	* 多道程序批处理：多道程序操作系统比单个程序或单道程序系统相对要复杂一些。对准备运行的多个作业，它们必须保留在主存储器中，这就需要内存管理(memory management)。此外，如果多个作业都准备运行，则处理器必须决定运行哪一个，这需要某种调度算法。
	* 分时系统：通过使用多道程序设计，可以使批处理变得更加有效。但是，对许多作业来说，需要提供一种模式，以使用户可以直接与计算机交互。实际上，对一些作业如事务处理，交互模式是必需的。正如多道程序设计允许处理器同时处理多个批作业一样，它还可以用于处理多个交互作业。对后一种情况，由于多个用户分享处理器时间，因而该技术称为分时(time sharing)。
	
### 主要的成就
>操作系统是最复杂的软件之一，这反映在为了达到那些困难的、甚至相互冲突的目标(方便、有效和易扩展性)而带来的挑战上。

* 在操作系统开发中有五个重要的理论进展： 进程、内存管理、 信息保护和安全、 调度和资源管理、 系统结构。
	* 每个进展都是为了解决实际的困难问题，并由相关原理或抽象概念来描述的。这五个领域包括了现代操作系统设计和实现中的关键问题。
	
#### 进程
<center>
<image src="./image/01-9.png">
典型进程实现方法
</center>
	
#### 内存管理
操作系统为满足这些要求，担负着五个基本的存储器管理责任：

* 进程隔离：操作系统必须保护独立的进程，防止互相干涉数据和存储空间。
* 自动分配和管理：程序应该根据需要在存储层次间动态地分配，分配对程序员是透明的。
* 支持模块化程序设计：程序员应该能够定义程序模块，并且动态地创建、销毁模块，改变模块大小。
* 保护和访问控制：不论在存储层次中的哪一级，存储器的共享都会产生一个程序访问另一个程序存储空间的潜在可能性。
* 长期存储：许多应用程序需要在计算机关机后长时间保存信息。

虚存机制允许程序从逻辑的角度访问存储器，而不考虑物理主存上可用的空间数量。虚存的构想是为了满足有多个用户作业同时驻留在主存中的要求。

当一个进程被写出到辅助存储器中并且后继进程被读入时，在连续的进程执行之间将不会脱节。由于进程大小不同，如果处理器在很多进程间切换，则很难把它们紧密地压入主存中，因此引进了分页系统。
	* 在分页系统中，进程由许多固定大小的块组成，这些块称为页。程序通过虚地址(Virtual address)访问字，虚地址由页号和页中的偏移量组成。进程的每一页都可以放置在主存中的任何地方。分页系统提供了程序中使用的虚地址和主存中的实地址(real address)或物理地址之间的动态映射。
	
#### 系统结构
>为了获得操作系统的一个概观，这里给出一个层次操作系统模型是很有用的。

尽管提出的模型没有对应于特定的操作系统，但它是很有用的。模型的定义见表1-5，由下面几层组成：
* 第l层：由电路组成，处理的对象是寄存器、存储单元和逻辑门。定义在这些对象上的操作是动作，如清空寄存器或读取存储单元。
* 第2层：处理器指令集合。该层定义的操作是机器语言指令集合允许的操作，如加、减、加载和保存。
* 第3层：增加了过程或子程序的概念，以及调用／返回操作。
* 第4层：引入了中断，能导致处理器保存当前环境、调用中断处理例程。
**前面四层并不是操作系统的部分，而是构成了处理器硬件。从第5层开始，才真正到达了操作系统，并开始出现和多道程序设计相关的概念。**

* 第5层：在这一层引入了进程的概念，用来表示程序的执行。操作系统运行多个进程的基本要求包括挂起和恢复进程的能力，这就要求保存硬件寄存器，以便可以从一个进程切换到另一个进程。此外，如果进程需要合作，则需要一些同步方法。操作系统设计中一个最简单的技术和重要的概念是信号量，简单信号机制
* 第6层：处理计算机的辅助存储设备。在这一层出现了定位读/写头和实际传送数据块的功能。第6层依赖于第5层对操作的调度和当一个操作完成后通知正在请求的进程的能力。更高层涉及到对磁盘中所需数据的寻址，并向第5层中的设备驱动程序请求相应的块。
* 第7层：为进程创建一个逻辑地址空间。这一层把虚地址空间组织成块，可以在主存和辅存之间移动。比较常用的有三个方案：使用固定大小的页、使用可变长度的段、两者都用。当所需要的块不在主存储器中时，这一层的逻辑将请求第6层的传送。
**操作系统处理的都是单处理器的资源。从第8层开始，操作系统处理外部对象，如外围设备和网络或网络中的计算机。这些位于高层的对象都是逻辑对象，命名对象可以在同一台计算机或在多台计算机间共享。**

* 第8层：处理信息通信和进程间的消息。尽管第5层提供了一个原始的信号机制，用于进程间的同步，但这一层处理更丰富的信息共享。用于此目的的强大工具之一是管道(pipe)，它是为进程间的数据流提供的一个逻辑通道。一个管道被定义成它的输出来自一个进程，而它的输入是到另一个进程中去。它还可用于把外部设备或文件链接到进程
* 第9层：支持称为文件的长期存储。在这一层，辅助存储器中的数据被看做是一个抽象的可变长度的实体。这与第6层辅助存储器中面向硬件的磁道、簇和固定大小的块形成对比。
* 第l0层：提供访问外部设备的标准接口。
* 第11层：负责维护系统资源和对象的外部标识符与内部标识符间的关联。外部标识符是应用程序和用户使用的名字；内部标识符是一个地址或可被操作系统低层使用、用于定位和控制一个对象的其他指示符。这些关联在目录中维护，目录项不仅包括外部／内部映射，而且包括诸如访问权之类的特性。
* 第l2层：提供了一个支持进程的功能完善的软件设施，这和第5层中所提供的大不相同。第5层只维护与进程相关的处理器寄存器内容和用于调度进程的逻辑，而第12层支持进程管理所需的全部信息，包括进程的虚地址空间、可能与进程发生交互的对象和进程的列表以及对交互的约束、在进程创建后传递给进程的参数和操作系统在控制进程时可能用到的其他特性。
* 第l3层：为用户提供操作系统的一个界面。它之所以称为命令行解释器(shell)，是因为它将用户和操作系统细节分离开，而简单地把操作系统作为一组服务的集合提供给用户。命令行解释器接受用户命令或作业控制语句，对它们进行解释，并在需要时创建和控制进程。例如，这一层的界面可以用图形方式实现，即通过菜单提供用户可以使用的命令，并输出结果到一个特殊设备(如显示器)来显示。

## Linux操作系统
### 模块结构

尽管Linux没有采用微内核的方法，但是由于它特殊的模块结构，也具有很多微内核方法的优点。Linux的结构是一个模块的集合，这些模块可以通过命令自动地加载和卸载。这些相对独立的块称为可加载模块(Loadable module)。
一个模块就是内核在运行时可以链接或断开链接的一个对象文件一个模块实现一些特定的功能，例如一个文件系统、一个设备驱动或是内核上层的一些特征。尽管一个模块可以因为不同目的而创建内核线程，但是它自身不作为进程或线程执行。虽然Linux被认为是单体内核，但是它的模块结构克服了在开发和发展内核过程中所遇到的困难。Linux可加载模块有两个重要特征：

* 动态链接：当内核已经在内存中并正在运行时，内核模块可以被加载和链接到内核。模块也可以在任何时刻被断开链接，从内存中移出。
* 可堆栈模块：模块按层次排列，当被高层的客户模块访问时，它们作为库；当被低层模块访问时，它们作为客户。
* 动态链接简化了配置任务，节省了内核所占的内存空间。在Linux中，用户程序或用户可以使用insmod和rmmod命令显式地加载和卸载内核模块，内核自身监视对于特定函数的需求，并可以根据需求加载和卸载模块。通过可堆栈模块可以定义模块间的依赖关系，这有两个好处：
* 对一组相似的模块，相同的代码(如相似硬件的驱动程序)可以移入一个模块，减少了重复。
* 内核可以确保所需要的模块都存在，避免卸载其他正在运行的模块仍然依赖着的模块，并且当加载一个新模块时，加载任何所需要的附加模块。
* 举例说明了Linux管理模块的结构，该图显示了当只有两个模块FAT和VFAT被加载后，内核模块的列表。每个模块由两个表定义，即模块表和符号表。模块表包括以下元素：
	* `*next`：指向后面的模块。所有模块被组织到一个链表中，链表以一个伪模块开始(图中没有显示)。
	* `*name`：指向模块名的指针。
	* `size`：模块大小，以内存页计。
	* `usecount`：模块引用计数器。当操作系统引用的模块函数开始时计数器增加，终止时减少。
	* `flags`：模块标志。
	* `nsyms`：输出的符号数。
	* `ndeps`：引用的模块数。
	* `*syms`：指向这个模块符号表的指针。
	* `*deps`：指向被这个模块引用的模块列表的指针。
	* `*refs`：指向使用这个模块的模块列表的指针。
<center>
<image src="./image/01-10.png">
01-10 显示VFAT模块加载到了FAT模块后，并且依赖于FAT模块。
</center>

### 内核组件
主要的内核组件的简要介绍如下：
* `信号(Signals)`：内核通过信号调用进程。例如，信号用来通知进程某些错误，比如被零除错误。
	* `SIGHUP` 终端挂起
	* `SIGQUIT` 键盘退出
	* `SIGTRAP` 跟踪陷阱
	* `SIGBUS` 总线错误
	* `SIGSEGV` 段错误
	* `SIGCHLD` 子状态改变
* `系统调用(System Calls)`：进程是通过系统调用来请求系统服务的。一共有几百个系统调用，可以粗略地分为六类：文件系统，进程，调度，进程间通信，套接字(网络)和其他。表1-7分别给出了每类系统调用的一些实例。
*  `进程和调度器(Processes and Scheduler)`：创建、管理、调度进程。
* `虚拟内存(Virtual Memory)`：为进程分配和管理虚拟内存。
*  `文件系统(File Systems)`：为文件、目录和其他与文件相关的对象提供一个全局的、层次化的命名空间，并提供文件系统函数。
* `网络协议(Network Protocols)`：为用户的TCP／IP协议套件提供套接字接口。
* 字符设备驱动(Character Device Drivers)：管理向内核一次发送或接收一个字节数据的设备，如终端、调制解调器和打印机。
* `块设备驱动(Block Device Drivers)`：管理以块为单位向内核发送和接收数据的设备，如各种形式的辅存(磁盘、CD．ROM等)。
* `网络设备驱动(Network Device Drivers)`：对网络接口卡和通信端口提供管理，它们负责连接到网桥或路由器之类的网络设备。
* `陷阱和错误(Traps and Faults)`：处理CPU产生的陷阱和错误，例如内存错误。
* `物理内存(Physical Memory)`：管理实际内存中的内存页池和为虚拟内存分配内存页
* `中断(Interrupts)`：处理来自外设的中断。
<center>
<image src="./image/01-11.png">
01-11 Linux内核组件
</center>
