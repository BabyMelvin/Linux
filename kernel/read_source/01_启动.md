[EFI、UEFI、MBR、GPT的区别](https://www.cnblogs.com/ricksteves/p/9800002.html)

# 处理器和寄存器的位数

* 32位处理器,能同时处理32位的数据，所以对应寄存器为32位的；
* 64位处理器,能同时处理64位的数据，所以对应寄存器为64位的；

# 寄存器

ARM64 有34个寄存器，包括31个通用寄存器、SP、PC、CPSR。

* x0-x30	64bit	通用寄存器，如果有需要可以当做32bit使用：WO-W30
* FP(x29)	64bit	保存栈帧地址(栈底指针)
* LR(x30)	64bit	通常称X30为程序链接寄存器，保存子程序结束后需要执行的下一条指令
* SP	64bit	保存栈指针,使用 SP/WSP来进行对SP寄存器的访问。
* PC	64bit	程序计数器，俗称PC指针，总是指向即将要执行的下一条指令,在arm64中，软件是不能改写PC寄存器的。
* CPSR	64bit	状态寄存器

其中

* x0-x7: 用于子程序调用时的参数传递，X0还用于返回值传递
* x0 - x30 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 当使用 x0 - x30 访问时，它就是一个64位的数。当使用 w0 - w30 访问时，访问的是这些寄存器的低32位

# 指令

* ARM64经常用到的汇编指令

```arm
MOV    X1，X0         ;将寄存器X0的值传送到寄存器X1
ADD    X0，X1，X2     ;寄存器X1和X2的值相加后传送到X0
SUB    X0，X1，X2     ;寄存器X1和X2的值相减后传送到X0

AND    X0，X0，#0xF    ; X0的值与0xF相位与后的值传送到X0
ORR    X0，X0，#9      ; X0的值与9相位或后的值传送到X0
EOR    X0，X0，#0xF    ; X0的值与0xF相异或后的值传送到X0

LDR    X5，[X6，#0x08]        ；ld：load; X6寄存器加0x08的和的地址值内的数据传送到X5
LDP  x29, x30, [sp, #0x10]    ; ldp :load pair ; 一对寄存器, 从内存读取数据到寄存器

STR X0, [SP, #0x8]         ；st:store,str:往内存中写数据（偏移值为正）; X0寄存器的数据传送到SP+0x8地址值指向的存储空间
STUR   w0, [x29, #-0x8]   ;往内存中写数据（偏移值为负）
STP  x29, x30, [sp, #0x10]    ;store pair，存放一对数据, 入栈指令

CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）
CBNZ ;比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）
CMP  ;比较指令，相当于SUBS，影响程序状态寄存器CPSR 

B   ;跳转指令，可带条件跳转与cmp配合使用
BL  ;带返回的跳转指令， 返回地址保存到LR（X30）
BLR  ; 带返回的跳转指令，跳转到指令后边跟随寄存器中保存的地址(例：blr    x8 ;跳转到x8保存的地址中去执行)
RET   ;子程序返回指令，返回地址默认保存在LR（X30）
```