# 计算机组成原理
> 处理器 主存储器 输入/输出模块 系统总线

## 处理器寄存器
* 用户可见寄存器：C语言中register
* 控制和状态寄存器
	* 程序计数器（pc）
	* 指令寄存器（IR）
	
<center>
<image src="./image/01-1.png" height="50%" width="50%">
</center>

### 指令的执行
	* 处理器最简单两步
		* 从存储器中读一条指令
		* 执行每条指令
	* 一个单一指令需要处理称为一个指令周期

<center>
<image src="./image/01-2.png">
01-2基本指令周期
</center>

* 取指令和执行指令
	* 每个指令周期开始时，处理器从存储器中去一条指令。
		* 典型处理器中，程序计数器（PC）保存下一次要取得指令地址
		* 取到的指令被放在处理器的一个寄存器中，指令寄存器（IR）
	* 处理器解释指令并执行对应操作分为四类：
		* 处理器-存储器：数据可以从处理器传送到存储器，或者从存储器传送到处理器。
		* 处理器-I/O：通过处理器和I/O模块间的数据传送，数据可以输出到外部设备，或者从外部设备输入数据。
		* 数据处理：处理器可以执行很多关于数据的算术操作或逻辑操作。
		* 控制：某些指令可以改变执行顺序。（跳转）
* 中断和指令周期

<center>
<image src="./image/01-3.png">
01-3 中断和指令周期
</center>

## 中断处理
* 中断发生激活很多事件，包括处理器硬件中的事件和软件中事件
	* 需要保存从中断点恢复当前程序所需要的信息，要求的最少信息包括程序状态宇(PSW)和保存在程序计数器中的下一条要执行的指令地址，它们被压入系统控制栈中。
	* 处理器把响应此中断的中断处理器入口地址装入程序计数器中。可以是针对每类中断有一个中断处理器，或者是针对每个设备和每类中断各有一个中断处理器，这取决于计算机系统结构和操作系统的设计。
	* 有多个中断处理器，处理器就必须决定调用哪一个，这个信息可能已经包含在最初的中断信号中，否则处理器必须给发中断的设备发送请求，以获取含有所需信息的响应。

<center>
<image src="./image/01-4.png">
f01-4 简单中断处理
</center>

* 多道程序设计
	* 提高CPU的利用率
### 存储器层次结构
* 存储器设计归结三个方面：
	* 存取时间越快，每“位”价格越高
	* 容量越大，每“位”价格就越低
	* 存量越大，存取速度就越慢
	
<center>
<image src="./image/01-5.png">
f01-4 简单中断处理
</center>

	*	多级存储可以实现，容量大，存储快。最成功关键：处理器访问存储器频率递减。
	*	软件中可以有效增加额外存储层次，一部分主存储器作为缓冲区，用于临时保存从磁盘中读出的数据。磁盘高速缓冲存储器。两种方法来提高性能：
		*	磁盘成簇写。次数少，数据量大传输方式。
		*	下次一定会访问到数据，数据能够迅速从软件设置磁盘高速缓冲存储器中取出，而不是缓慢的磁盘中取回。
### I/O通讯技术
* I/O操作有三种可能的技术：
	* 可编程I/O
	* 中断驱动I/O
	* 直接存储器访问（Direct Memory Access ,DMA）
* **可编程I/O**
* 如果使用这种技术，处理器负责从主存储器中提取数据以用于输出，并在主存储器中保存数据以用于输入。这是一个耗时的处理，处理器总是处于没有用的繁忙中。处理器通常必须等待很长的时间，以确定I/O模块是否做好了接收或发送更多数据的准备。
	* 当处理器正在执行程序并遇到一个与I/O相关的指令时，它通过给相应的I/O模块发命令来执行这个指令。
	* 使用可编程I/O操作时，I/O模块执行请求的动作并设置I/O状态寄存器中相应的位，它并不进一步通知处理器，尤其是它并不中断处理器。
	* 因此处理器在执行I/O指令后，还要定期检查I/O模块的状态，以确定I/O操作是否已经完成。
		* I/O软件应该设计为由处理器执行直接控制I/O操作的指令，包括检测设备状态、发送读命令或写命令和传送数据，因此指令集中包括以下几类I/O指令：
			* 控制：用于激活外部设备，并告诉它做什么。例如，可指示磁带倒退或前移一条记录。
			* 状态：用于测试与I/0模块及其外围设备相关的各种状态条件。
			* 传送：用于在存储器寄存器和外部设备间读数据或写数据。
* **中断驱动I/O**
* 处理器给模块发送I/O命令，然后继续做其他一些有用的工作。当I/0模块准备好与处理器交换数据时，它将打断处理器的执行并请求服务。
	*	I/O模块:输入操作，I/O模块从处理器中接收一个READ命令，然后开始从相关的外围设备读数据。一旦数据被读入该模块的数据寄存器，模块通过控制线给处理器发出一个中断信号，然后就等待，直到处理器请求该数据。当处理器发出这个请求后，模块把数据放到数据总线上，然后准备下一次I/O操作。
	*	处理器：输入,处理器发一个READ命令，然后保存当前程序的上下文(如程序计数器和处理器寄存器)，离开当前程序，做其他事情(例如，处理器可以同时在几个不同的程序中工作)。在每个指令周期的末尾，处理器检查中断.当发生来自I/0模块的中断时，处理器保存当前正在执行的程序的上下文，开始执行中断处理程序处理此中断。

<center>
<image src="./image/01-6.png">
01-6
</center>

* 在某些系统中有多条中断线，这样每个模块就可在不同的线上发中断信号，每条中断线有不同的优先级。
当然，也可能只有一条中断线，但要使用额外的线来保存设备地址，而且不同的设备有不同的优先级。
* **直接存储器访问**
* I/O传送速度受限于处理器测试设备和提供服务的速度。
* 不论采用哪种形式，该技术的工作方式如下所示：当处理器要读或写一块数据时，它给DMA模块发出一条命令，发送以下信息：
	* 是否请求一次读或写
	* 涉及的I/O设备的地址
	* 开始读或写的存储器单元
	* 需要读或写的字数
* 处理器然后继续其他工作。处理器把这个操作委托给DMA模块，由该模块负责处理。DMA模块直接与存储器交互，传送整个数据块，每次传送一个字。这个过程不需要处理器参与。当传送完成后，DMA模块发一个中断信号给处理器。因此只有在开始传送和传送结束时处理器才会参与
* 注意，这并不是一个中断，处理器没有保存上下文去做别的事情，而是仅仅暂停一个总线周期(在总线上传输一个字的时间)。其总的影响是在DMA传送过程中，当处理器需要访问总线时处理器的执行速度会变慢。尽管如此，对多字I/O传送来说，DMA比中断驱动和程序控制I/O更有效。
##操作系统概述
###操作系统目标功能
* 操作系统是控制应用程序执行的程序，并充当应用程序和计算机硬件之间的接口。它有下面三个目标：
	* 方便：操作系统使计算机更易于使用。
	* 有效：操作系统允许以更有效的方式使用计算机系统资源。
	* 扩展的能力：在构造操作系统时，应该允许在不妨碍服务的前提下有效地开发、测试和引进新的系统功能。
### 用户/计算机接口
* 操作系统通常提供了以下几个方面的服务：
	* 程序开发：操作系统提供各种各样的工具和服务，如编辑器和调试器，用于帮助程序员开发程序。通常，这些服务以实用工具程序的形式出现，严格来说并不属于操作系统核心的一部分；它们由操作系统提供，称为应用程序开发工具。
	* 程序运行：运行一个程序需要很多步骤。必须把指令和数据载入到主存储器、初始化I/O设备、准备其他一些资源。操作系统为用户处理这些调度问题。
	* I/O设备访问：每个I/O设备的操作都需要自己特有的指令集或控制信号，操作系统隐藏这些细节，并提供统一的接口，因此程序员可以使用简单的读和写操作来访问这些设备。
	* 文件访问控制：对操作系统而言，关于文件的控制不仅必须详细了解I／O设备(磁盘驱动器、磁带驱动器)的特性，而且必须详细了解存储介质中文件数据的结构。此外，对有多个用户的系统，操作系统还可以提供保护机制来控制对文件的访问。
	* 系统访问：对于共享或公共系统，操作系统控制对整个系统的访问以及对某个特殊系统资源的访问。访问功能模块必须提供对资源和数据的保护，以避免未授权用户的访问，还必须解决资源竞争时的冲突问题。
	* 错误检测和响应：计算机系统运行时可能发生各种各样的错误，包括内部和外部硬件错误，如存储器错误、设备失败或故障，以及各种软件错误，如算术溢出、试图访问被禁止的，存储器单元、操作系统无法确认应用程序的请求等。
	* 审计：一个好的操作系统可以收集对各种资源的审计，监控诸如响应时间之类的性能参数。
<center>
<image src="./image/01-7.png">
</center>

### 资源管理器的操作系统
>一台计算机就是一组资源，这些资源用于对数据的移动、存储和处理以及对这些功能的控制。而操作系统负责管理这些资源。

* 操作系统与普通的计算机软件作用相同，也就是说，它是由处理器执行的一段程序或一组程序。
* 操作系统经常会释放控制，而且必须依赖处理器才能恢复控制。
* 操作系统实际上不过是一组计算机程序，与其他计算机程序类似，它们都给处理器提供指令，主要区别在于程序的意图。
	* 操作系统控制处理器使用其他系统资源，并控制处理器运行其他程序的时间安排。
	* 但是，处理器为了做任何一件这类事情，都必须停止执行操作系统程序，而去执行其他程序。因此，这时操作系统释放对处理器的控制，让处理器去做其他一些有用的工作，然后用足够长的时间恢复控制，让处理器准备好做下一件工作。
* 操作系统有一部分在主存中，其中包括内核程序(kernel或nucleus)和当前正在使用的其他操作系统程序，内核程序包含操作系统中最常使用的功能。主存的其余部分包含其他用户程序和数据。
* 资源(主存)的分配由操作系统和处理器中的存储管理硬件联合控制。
* 操作系统决定在程序运行过程中何时使用I/O设备，并控制文件的访问和使用。
* 处理器自身也是一个资源，操作系统必须决定在运行一个特定的用户程序时，可以分配多少处理器时间。在多处理器系统中，这个决定要传到所有的处理器。
<center>
<image src="./image//01-8.png">
01-8 操作系统作为资源管理器
</center>

###操作系统易扩展
* 操作系统不断发展，主要满足硬件和软件需求。纠错能力不断增强。
* 操作系统发展
	* 串行处理：没有操作系统概念。问题->调度和准备时间
	* 简单批处理系统：监控软件。
	* 多道程序批处理：多道程序操作系统比单个程序或单道程序系统相对要复杂一些。对准备运行的多个作业，它们必须保留在主存储器中，这就需要内存管理(memory management)。此外，如果多个作业都准备运行，则处理器必须决定运行哪一个，这需要某种调度算法。
	* 分时系统：通过使用多道程序设计，可以使批处理变得更加有效。但是，对许多作业来说，需要提供一种模式，以使用户可以直接与计算机交互。实际上，对一些作业如事务处理，交互模式是必需的。正如多道程序设计允许处理器同时处理多个批作业一样，它还可以用于处理多个交互作业。对后一种情况，由于多个用户分享处理器时间，因而该技术称为分时(time sharing)。
### 主要的成就
>操作系统是最复杂的软件之一，这反映在为了达到那些困难的、甚至相互冲突的目标(方便、有效和易扩展性)而带来的挑战上。

* 在操作系统开发中有五个重要的理论进展： 进程、内存管理、 信息保护和安全、 调度和资源管理、 系统结构。
	* 每个进展都是为了解决实际的困难问题，并由相关原理或抽象概念来描述的。这五个领域包括了现代操作系统设计和实现中的关键问题。
* **进程**
<center>
<image src="./image/01-9.png">
典型进程实现方法
</center>
* **内存管理**
* 操作系统为满足这些要求，担负着五个基本的存储器管理责任：
	* 进程隔离：操作系统必须保护独立的进程，防止互相干涉数据和存储空间。
	* 自动分配和管理：程序应该根据需要在存储层次间动态地分配，分配对程序员是透明的。
	* 支持模块化程序设计：程序员应该能够定义程序模块，并且动态地创建、销毁模块，改变模块大小。
	* 保护和访问控制：不论在存储层次中的哪一级，存储器的共享都会产生一个程序访问另一个程序存储空间的潜在可能性。
	* 长期存储：许多应用程序需要在计算机关机后长时间保存信息。
* 虚存机制允许程序从逻辑的角度访问存储器，而不考虑物理主存上可用的空间数量。虚存的构想是为了满足有多个用户作业同时驻留在主存中的要求。
* 当一个进程被写出到辅助存储器中并且后继进程被读入时，在连续的进程执行之间将不会脱节。由于进程大小不同，如果处理器在很多进程间切换，则很难把它们紧密地压入主存中，因此引进了分页系统。
	* 在分页系统中，进程由许多固定大小的块组成，这些块称为页。程序通过虚地址(Virtual address)访问字，虚地址由页号和页中的偏移量组成。进程的每一页都可以放置在主存中的任何地方。分页系统提供了程序中使用的虚地址和主存中的实地址(real address)或物理地址之间的动态映射。
* **系统结构**
>为了获得操作系统的一个概观，这里给出一个层次操作系统模型是很有用的。

* 尽管提出的模型没有对应于特定的操作系统，但它是很有用的。模型的定义见表1-5，由下面几层组成：
	* 第l层：由电路组成，处理的对象是寄存器、存储单元和逻辑门。定义在这些对象上的操作是动作，如清空寄存器或读取存储单元。
	* 第2层：处理器指令集合。该层定义的操作是机器语言指令集合允许的操作，如加、减、加载和保存。
	* 第3层：增加了过程或子程序的概念，以及调用／返回操作。
	* 第4层：引入了中断，能导致处理器保存当前环境、调用中断处理例程。
	* *前面四层并不是操作系统的部分，而是构成了处理器硬件。从第5层开始，才真正到达了操作系统，并开始出现和多道程序设计相关的概念。*
	* 第5层：在这一层引入了进程的概念，用来表示程序的执行。操作系统运行多个进程的基本要求包括挂起和恢复进程的能力，这就要求保存硬件寄存器，以便可以从一个进程切换到另一个进程。此外，如果进程需要合作，则需要一些同步方法。操作系统设计中一个最简单的技术和重要的概念是信号量，简单信号机制
	* 第6层：处理计算机的辅助存储设备。在这一层出现了定位读/写头和实际传送数据块的功能。第6层依赖于第5层对操作的调度和当一个操作完成后通知正在请求的进程的能力。更高层涉及到对磁盘中所需数据的寻址，并向第5层中的设备驱动程序请求相应的块。
	* 第7层：为进程创建一个逻辑地址空间。这一层把虚地址空间组织成块，可以在主存和辅存之间移动。比较常用的有三个方案：使用固定大小的页、使用可变长度的段、两者都用。当所需要的块不在主存储器中时，这一层的逻辑将请求第6层的传送。
	* *操作系统处理的都是单处理器的资源。从第8层开始，操作系统处理外部对象，如外围设备和网络或网络中的计算机。这些位于高层的对象都是逻辑对象，命名对象可以在同一台计算机或在多台计算机间共享。*
	* 第8层：处理信息通信和进程间的消息。尽管第5层提供了一个原始的信号机制，用于进程间的同步，但这一层处理更丰富的信息共享。用于此目的的强大工具之一是管道(pipe)，它是为进程间的数据流提供的一个逻辑通道。一个管道被定义成它的输出来自一个进程，而它的输入是到另一个进程中去。它还可用于把外部设备或文件链接到进程
	* 第9层：支持称为文件的长期存储。在这一层，辅助存储器中的数据被看做是一个抽象的可变长度的实体。这与第6层辅助存储器中面向硬件的磁道、簇和固定大小的块形成对比。
	* 第l0层：提供访问外部设备的标准接口。
	* 第11层：负责维护系统资源和对象的外部标识符与内部标识符间的关联。外部标识符是应用程序和用户使用的名字；内部标识符是一个地址或可被操作系统低层使用、用于定位和控制一个对象的其他指示符。这些关联在目录中维护，目录项不仅包括外部／内部映射，而且包括诸如访问权之类的特性。
	* 第l2层：提供了一个支持进程的功能完善的软件设施，这和第5层中所提供的大不相同。第5层只维护与进程相关的处理器寄存器内容和用于调度进程的逻辑，而第12层支持进程管理所需的全部信息，包括进程的虚地址空间、可能与进程发生交互的对象和进程的列表以及对交互的约束、在进程创建后传递给进程的参数和操作系统在控制进程时可能用到的其他特性。
	* 第l3层：为用户提供操作系统的一个界面。它之所以称为命令行解释器(shell)，是因为它将用户和操作系统细节分离开，而简单地把操作系统作为一组服务的集合提供给用户。命令行解释器接受用户命令或作业控制语句，对它们进行解释，并在需要时创建和控制进程。例如，这一层的界面可以用图形方式实现，即通过菜单提供用户可以使用的命令，并输出结果到一个特殊设备(如显示器)来显示。
## Linux操作系统
### 模块结构
* 尽管Linux没有采用微内核的方法，但是由于它特殊的模块结构，也具有很多微内核方法的优点。Linux的结构是一个模块的集合，这些模块可以通过命令自动地加载和卸载。这些相对独立的块称为可加载模块(Loadable module)。
* 一个模块就是内核在运行时可以链接或断开链接的一个对象文件
	* 一个模块实现一些特定的功能，例如一个文件系统、一个设备驱动或是内核上层的一些特征。尽管一个模块可以因为不同目的而创建内核线程，但是它自身不作为进程或线程执行。
* 虽然Linux被认为是单体内核，但是它的模块结构克服了在开发和发展内核过程中所遇到的困难。Linux可加载模块有两个重要特征：
	* 动态链接：当内核已经在内存中并正在运行时，内核模块可以被加载和链接到内核。模块也可以在任何时刻被断开链接，从内存中移出。
	* 可堆栈模块：模块按层次排列，当被高层的客户模块访问时，它们作为库；当被低层模块访问时，它们作为客户。
* 动态链接简化了配置任务，节省了内核所占的内存空间。在Linux中，用户程序或用户可以使用insmod和rmmod命令显式地加载和卸载内核模块，内核自身监视对于特定函数的需求，并可以根据需求加载和卸载模块。通过可堆栈模块可以定义模块间的依赖关系，这有两个好处：
	* 对一组相似的模块，相同的代码(如相似硬件的驱动程序)可以移入一个模块，减少了重复。
	* 内核可以确保所需要的模块都存在，避免卸载其他正在运行的模块仍然依赖着的模块，并且当加载一个新模块时，加载任何所需要的附加模块。
* 举例说明了Linux管理模块的结构，该图显示了当只有两个模块FAT和VFAT被加载后，内核模块的列表。每个模块由两个表定义，即模块表和符号表。模块表包括以下元素：
	* *next：指向后面的模块。所有模块被组织到一个链表中，链表以一个伪模块开始(图中没有显示)。
	* *name：指向模块名的指针。
	* size：模块大小，以内存页计。
	* usecount：模块引用计数器。当操作系统引用的模块函数开始时计数器增加，终止时减少。
	* flags：模块标志。
	* nsyms：输出的符号数。
	* ndeps：引用的模块数。
	* *syms：指向这个模块符号表的指针。
	* *deps：指向被这个模块引用的模块列表的指针。
	* *refs：指向使用这个模块的模块列表的指针。
<center>
<image src="./image/01-10.png">
01-10 显示VFAT模块加载到了FAT模块后，并且依赖于FAT模块。
</center>

### 内核组件
* 主要的内核组件的简要介绍如下：
	* 信号(Signals)：内核通过信号调用进程。例如，信号用来通知进程某些错误，比如被零除错误。
		* SIGHUP 终端挂起
		*	SIGQUIT 键盘退出
		* SIGTRAP 跟踪陷阱
		*	SIGBUS 总线错误
		*	SIGSEGV 段错误
		*	SIGCHLD 子状态改变

	* 系统调用(System Calls)：进程是通过系统调用来请求系统服务的。一共有几百个系统调用，可以粗略地分为六类：文件系统，进程，调度，进程间通信，套接字(网络)和其他。表1-7分别给出了每类系统调用的一些实例。
	* 进程和调度器(Processes and Scheduler)：创建、管理、调度进程。
	* 虚拟内存(Virtual Memory)：为进程分配和管理虚拟内存。
	* 文件系统(File Systems)：为文件、目录和其他与文件相关的对象提供一个全局的、层次化的命名空间，并提供文件系统函数。
	* 网络协议(Network Protocols)：为用户的TCP／IP协议套件提供套接字接口。
	* 字符设备驱动(Character Device Drivers)：管理向内核一次发送或接收一个字节数据的设备，如终端、调制解调器和打印机。
	* 块设备驱动(Block Device Drivers)：管理以块为单位向内核发送和接收数据的设备，如各种形式的辅存(磁盘、CD．ROM等)。
	* 网络设备驱动(Network Device Drivers)：对网络接口卡和通信端口提供管理，它们负责连接到网桥或路由器之类的网络设备。
	* 陷阱和错误(Traps and Faults)：处理CPU产生的陷阱和错误，例如内存错误。
	* 物理内存(Physical Memory)：管理实际内存中的内存页池和为虚拟内存分配内存页
	* 中断(Interrupts)：处理来自外设的中断。
<center>
<image src="./image/01-11.png">
01-11 Linux内核组件
</center>
