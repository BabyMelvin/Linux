内核作为一个庞大的系统，要保证扩展性和可维护性，里面用到了大量设计模式。说到设计模式就很容易联想到面向对象，联想到 C++。那么，内核为什么不使用 C++呢。我想是出于效率和平台可移植性的考虑。C++编译器实现起来比 C 复杂多了，想像一下很多编译器都不是 100%地支持 C++标准。所以在一些非主流的硬件上，不一定能找到对应的 C++编译器。

虽然内核使用的是 C，但是，内核仍然采用了面向对象的思想。尤其是在文件系统和设备驱动这一块。在这些地方，集中了大量的结构体如`file`,`dentry`,`inode`,`cdev`,`block_device`,`pci_dev`,`usb_device`,`file_operations` 等等以及大量的函数和宏。我们的目标是理清它们之间的关系，最好能搞清楚为什么要这么设计。如果用面向对象的观点来阅读源代码，很多地方就显得清晰易懂了。好，让我们跟着问题走：

> 问题一：用 C 如何实现 C++中常见的类，成员函数，虚函数表，多态，继承，封装等等特性呢？

稍加整理，我们可以发现，结构体主要可以分成两类。

* 一类定义了很多数据成员，如struct file.
* 一类定义了很多函数指针，如 struct file_operations。

并且这两者是一一对应的。其中，file_operations 可以看作是接口。file 中可以看作是类，而里面的成员变量`f_op`可以看作是虚函数表指针。

只是没有 C++的访问权限控制机制罢了。与此类似的还有
dentry 和 dentry_operations，inode 和 inode_operations。这样，我们用 C 的结构体和函数指针模拟出了类，成员函数，虚函数表。你可能觉得这样很不直观。是的，很不直观，不过谁叫我们用的是 C 呢？

> 还有更不直观的，下面要介绍的模板就是。

这里可以看出，类与接口的区别。类包括了数据和成员函数，也就是“实现”，而接口只是一组操作的集合，类似于抽象类。接口的作用是屏蔽内部细节，方便上层的开发者开发一个通用的模型。对下层的开发者而言，只要实现接口的功能就行。在 C++里是不区别类与接口的。而在 Java 里则在类之外还提供了接口的功能。扯远了，打住。

虚函数表有了，那么，要实现多态，就要实现动态绑定。我们知道，在 C++中，编译器会根据类声明中的 virtual 关键字为每个类初始化一张虚函数表，然后，在每个对象构造的时候，把对象中的一个指针指向对应的虚函数表。现在 C 编译器宣布它撂担子不管这事了。所以这些辛苦活只能让我们自己来干喽~。以 inode 为例。假设文件系统是 ext2。我们要读的是一个普通的 ext2 文件。

```c
sys_open()->filp_open()->open_namei()->path_lookup()->link_path_walk()-
>__link_path_walk()->open_namei()->path_lookup()->do_lookup()->real_lookup()-
>ext2_lookup()->ext2_read_inode()
```
最后，在 ext2_read_inode()中，它会根据 inode 类型把 i_op 设置成相应的inode_operations。这一步相当于 C++的构造函数中的动态绑定，即根据 inode 类型来决定对应的操作。通过这种方式实现了多态。
虽然多态很好地实现了抽象，方便了软件的扩展，但是我得说它给我的代码阅读带来了很大的不便。跟踪函数时经常到了有函数指针（类似于虚函数）时就中断了，很难知道它究竟调用的是哪个函数。
