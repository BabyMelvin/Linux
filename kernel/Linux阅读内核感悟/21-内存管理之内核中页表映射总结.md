从线性地址到物理地址的转换，实际上是一种映射。所有进程的 3~4G 的线性地址实际上是映射到相同的物理地址的。这一点不多说了。为了方便起见，3~4G 的线性地址与对应的物理地址基本上是呈线性关系的。即**线性地址=物理地址+3G**。。但是如果把这 1G 的线性地址都简单地处理为对应物理地址+3G，就会有新的问题产生。例如，如果物理地址大于 4G，那么内核就没法访问这些地址了。所以，内核必须要从这 1G 的线性空间中预留一部分，作其它用途，（例如，映射高端物理地址）。经过实践，发现 128M线性地址够用了。所以，3~4G 的线性地址中 896M 映射到物理地址中的 0~896M，剩下的 128M挪作它用，例如，内核空间的非线性映射（在 vmalloc 中使用）以及高于 4G 的物理地址的映射。

我曾经产生过的疑问：

> 1.如果物理内存小于 896M，那不是所有的物理地址都被内核用完，没有内存留给用户空间了么？
事实上，小于 896M 时，同一块物理内存可能同时被映射到用户空间和内核空间，从数学的角度来讲，也就是所谓的“双箭一雕”。我们相信内核是没有 bug 的，所以不用担心因此产生的内核对用户空间数据破坏的可能性。

> 2.如果物理内存小于 896M，所有物理内存地址都与内核线性地址相差 3G，那 vmalloc不是没有内存使用了么？
不使用 vmalloc 当然是不可能的，因为模块装载时就会用到 vmalloc。原理与问题 1 一样，即使在内核空间，也可能多个线性地址映射到同一个物理地址，也就是“双箭一雕”。所以 vmalloc 仍然能获得相应的物理内存。

**对以上两个问题的小结**。系统在启动时会把前 896M 物理地址映射到 3G 以上的线性空间。但是映射不等于使用。事实上内核只使用了很小一部分（一般才几 M）。只要有足够的未使用的物理内存，用户进程和 vmalloc 都不会有问题。

> 3.如果物理内存大于 896M。那对内核而言不是无法在同一时刻访问所有的物理内存了么？
是的，虽然内核可以通过临时映射和永久映射来访问所有的物理内存，但是用到的线性地址很有限，即一次只能访问一小部分物理内存。当无法访问到更高地址物理内存时，只能通过修改内核页表来达到目的。但是，这对内核就足够了。因为上面说过，内核所需要的内存很少。内核只是偶尔会访问一下高端内内存。而对于用户进程而言，只要页表开启了PAE，就可以访问 64G 以内的物理内存（虽然只有 4G 的线性空间，但是也足够了。）

> 4.内核页表是如何共享的呢？
我们知道所有的**进程共享内核空间**，所以共享内核页表是很自然的事。理论上内核只有一个页表，对应的内核全局页目录 swapper_pg_dir，所有进程的页目录的最高 256 项与swapper_pg_dir 相同。可惜的是，每个进程有自己的页目录，共 1024 项。其中最高的 256项指向的是内核空间。尽管这些页目录项可以指向同样的内核页表，但是一旦内核页目录改变了，所有进程的页目录都需要同步。这种情况是存在的。比如内核调用 vmalloc 时。

幸亏有了页错误，我们可以从容地处理页目录的同步。如果内核调用了 vmalloc，内核只修改内核全局页目录。当其它进程访问 vmalloc 产生的线性空间时，会产生页错误。页错误处理程序可以判断当前的页错误是由于 vmalloc 产生的，于是修改对应的页目录，使它们与内核全局页目录保持一致。
