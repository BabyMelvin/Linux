“真罗嗦，直接告诉我 Linux 下用 glibc 库编译出来的 C 程序真正的入口地址是_start()不就行了么？”臭鸡蛋扑面而来。嗯，我说了我只是想用一种特别的方式来叙述问题。我更看重探索的过程中体现的思考方式以及其中的乐趣。回到我们的主题。

> Linux 内核为什么不是从 main 函数开始执行？

事实上，Linux 内核源代码里有许多`main()`函数，但仔细一看。他们都是运行在用户态的。其实，从上一节中
可以看到，main()函数只是一个符号而已。很多书上提到`start_kernel()`。它类似于main()。但正如调用 main()的是_start()。在 start_kernel 之前仍然有很多代码。所以内核的真正入口并不是`start_kernel()`。


真正决定程序执行入口的是**载入程序**。对普通的 C 程序 helloworld 来说，Linux 内核（严格的说应该是 bash）负责设置 helloworld 的入口点，并且启动 helloworld 进程的执行。

于是，问题出现了

> Linux 内核的载入程序是什么呢？难道是自己载入自己？
这类类似的问题在计算机史上出现过很多次.比如，C 程序可以用 C 编译器来写，那么，C 编译器用什么来写呢？当然，解决的方案有很多种，比如，用汇编语言写。那么汇编器用什么写呢？可以用机器语言写。虽然是件痛苦的事，但是一想到能造福这么多人，(发散一下，C 编译器可以编译出各种新的语言的编译器或者解释器如 perl，然后程序员们再用perl 来编出各种复杂的系统)，简直太伟大了，那位用机器语言写汇编器的程序员一定会浑身干劲。

可以借鉴一下思路，这类问题的**常见的解决方式**是构造一个简单的系统来解决一个复杂的系统的问题，如此往复，像滚雪球一下，最终把一个极为复杂的问题解决掉。

所以，很自然的想到，用一个简单的内核，（不，它仅仅是一段程序，甚至不能称之为内核，因为它的功能很有限）来启动真正的内核。就像用一个**小当量的原子弹**来引**爆氢弹一样**。

# 1.引导内核
本着 KISS(keep it simple and stupid)的原则，你第一时间可能会想到 BIOS。BIOS通常存在 ROM 上。随着 ROM 容量的扩展（达 1M 甚至更多）PC 上的 BIOS 功能已经很强大了，包括了很多设备的驱动程序。不仅可以进行硬件的检测，还实现了基本的输入输出功能。（basic input / output system，这也是它的本意）。开机时按 del 键出现的 BIOS 设置画面就是 BIOS 的杰作。在 BIOS 上实现一个 OS 也不是不可能。事实上**DOS**就是在 BIOS 的基础上实现的。

然而，BIOS 的**一个致命的缺点**是到目前为止它基本上只能在 16 位实地址模式下运行，毕竟 ROM 的容量很有限。（当然也不绝对，BIOS 也提供了在保护模式下扫描 PCI 设备的方法，大牛们 yy 一下实现一个保护模式下运行的 BIOS 的可行性。）而 CPU 刚加电时处在 16位实地址模式下。它的**另一个致命的缺点**是太小。因为现代操作系统多种多样，BIOS 再强大也无法把所有可能的情况都考虑进去。

不过即使这样，PC 机刚启动时，x86 CPU 仍然会自动从 BIOS 开始启动，这是由硬件决定的，因为**加电时**，寄存器 CS 里的值为 0xffff，IP 里的值为 0。于是 CPU 从线性地址0xffff0 处开始取指令。0xffff0 处是什么地方呢？运行`cat /proc/iomem`

前面 5 行

```
00000000-0009fbff : System RAM
0009fc00-0009ffff : reserved
000a0000-000bffff : Video RAM area
000c0000-000cc7ff : Video ROM
000f0000-000fffff : System ROM
```
可以看到 0xffff0 处是 System ROM，也就是 BIOS.注意这里的地址是 16 位实地址模式下的线性地址。

而BIOS能做的事，包括开机时对设备的检测，最后去读**硬盘上的第一个扇区**（即引导扇区MBR）的 512 个字节，把它们拷贝到地址为 **0x7c00** 处的内存中。到此为止，BIOS 的引导使命已经完成。虽然以后 Linux 内核的引导还要用到 BIOS 的功能，但引导的使命已经落在其它程序上了。