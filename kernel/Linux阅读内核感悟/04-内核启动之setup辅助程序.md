我们发现，在起点与终点之间，还有几个中转站。最近的一站叫作 MBR。BIOS，带你到 MBR 后，说：“对不起，只能送你到这里了。”

> 那其它几个中转站是什么呢？

我们知道，在 x86 上，保护模式有两种，32 位页式寻址的保护模式和 32 位段式寻址的保护模式。。显然，32 位页式寻址的保护模式要求系统中已经构造好页表。从 16 位实地址模式直接到 32 位页式寻址的保护模式是很有难度的，因为你要在 16 位实地址模式下构造页表。所以不妨三级跳，先从 16 位实地址模式跳到 32 位段式寻址的保护模式，再从 32 位段式寻址的保护模式跳到 32 位页式寻址的保护模式。

# 1.setup程序
我们需要这样一个程序，负责从 16 位实地址模式跳到 32 位段式寻址的保护模式，然后设置 eip，启动内核。这个程序的确存在，就是 `arch/i386/boot/setup.S`。最后汇编成setup 程序。

# 2.bzImage
事实上，平时所见的压缩内核映象bzImage，其实由三部分组成。这可以从`arch/i386/boot/tools/build.c`中看出来。build.c 是**用户态工具**build的源代码，后者用来把bootsect(MBR),setup(辅助程序)和 vmlinux.bin(压缩过的内核)拼接成 bzImage。

# 3.启动内核

setup 有了，它可以启动内核，然而新的问题来了。谁来启动 setup 呢？第一个想到的是 MBR。可惜，MBR 只有 512 个字节，而且有 64 个字节来存放主分区表。这样看来，MBR的功能就很有限了。

所以，最好在 setup 和 MBR 之间再架一座桥梁。引导程序，对，用它来引导 setup 再合适不过了。现有的引导程序如 **grub**,**lilo** 不仅功能强大，而且还提供了人机交互的功能。再合适不过了。

所以，我们理清了大概思路，查阅相关资料可知：

* 1.CPU 加电，从0xffff0处，执行BIOS（可以理解为“硬件”引导 BIOS）
* 2.BIOS 执行扫描检测设备的操作，然后将MBR读到物理地址为`0x7c00`处。然后从 MBR 头部开始执行（可以理解为 BIOS 引导 MBR）
* 3.MBR 上的代码跳转到引导程序，开始执行引导程序的代码，例如 grub（引以理解为BIOS引导 boot loader）
* 4.引导程序把内核映象(包括 bootsect，setup，vmlinux)读到内存中，其中 setup 位于0x90200 处
  * 如果是 zImage，则 vmlinux.bin 位于 `0x10000`（64K）处。
  * 如果是 bzImage，则vmlinux.bin 位于 `0x100000`（1M）处。
  * 然后执行 setup（可以理解为 boot loader 引导setup）
* 5.setup 负责引导 linux 内核 vmlinux.bin

# 4.setup做了啥

> 现在，让我们看看 setup 做了些什么。

首先，运行一下`file setup`它报告说这是一个 MS DOS 的可执行程序。看来，file 也有不正常工作的时候。不过有一点是肯定的。setup 不是普通的 elf 可执行程序。事实上，gcc 可以编译出各种格式的程序，具体可以运行`objdump -i`，查看 ld（gcc 的链接器）支持的输出格式。其中有一个是binary 格式。

从 start 开始，setup 做了很多操作，例如，如果是 zImage，则把它从 0x10000 拷贝到 0x1000，调用 bios 功能，查询硬件信息，然后放在内存中供将来的内核使用，然后建立临时的 idt 和 gdt，负责把 16 位实地址模式转化为 32 位段式寻址的保护模式。前面这些我们不关心。我们关心的是后者：

```s
832 movw $1, %ax # protected mode (PE) bit
833 lmsw %ax # This is it!
```
正是以下指令开启了保护模式的大门。最后，再临门一脚

* 对 bzImage 来说：`jmpi 0x100000,__BOOT_CS`
* 对 zImage 来说：`jmpi 0x1000,__BOOT_CS`

就大功告成了。

不过，且慢，由于当时 CS 寄存器还没有设置为__BOOT_CS，所以，尽管在保护模式下，也仍然不能用通常的方式访问大于 1M 的内存。不过，x86 处理器提供了特殊的手段来访问大于 1M 的内存，那就是在指令前加前缀 0x66。由于跳转地址与内核大小相关（zImage 和 bzImage 不一样）所以用一个小技巧，即把该指令当作数据处理。在计算机看来，指令和数据是没什么区别的，只要 ip 寄存器指向内存中某地址，计算机就把地址中的数据当作指令来看待。

```s
854 .byte 0x66, 0xea # prefix + jmpi-opcode
855 code32: .long 0x1000 # will be set to 0x100000
856 # for big kernels
857 .word __BOOT_CS
```
我不仅发出感慨：看 setup.S 的代码真是一种痛苦的体验，并且有以下感悟：

> 1.为什么不用 C 写呢？
原因很简单，因为 setup 要尽量短小精悍，由于种种原因，它的大小不能超过 63.5K.启动时内存分配如下：

```
0x00000~0x00400 BIOS 中断向量表
0x00400~0x01000
0x01000~0x10000
0x10000~0x8f000 用来存放 zImage 所以最多 508K
0x8f000~0x90000 引导程序的命令行参数以及 bios 查询的信息
0x90000~0x90200 MBR
0x90200~0xA0000 setup
0xA0000~0x100000 映射到 BIOS 和外设硬件等
0x100000~ 存放 bzImage(如果大于 508K)
```

> 2.如何引用变量？
在 setup.S 中，定义了不少全局变量。在编译生成 setup 文件时，链接参数`LDFLAGS_setup := -Ttext 0x0 -s --oformat binary -e begtext`

* 意为 text 段的地址为 0，输出格式为 binary（而不是默认的 elf32-i386），入口地址begtext。

由于基本上处于 16 位实模式下，所以只要设置好 CS 等段寄存器就可以正确地寻址了。现在我们跳到 vmlinux.bin 的开头(位于 0x1000 或者 0x100000)，也就是 `startup_32()`，执行相应代码。

> 3.helloworld，vmlinux，arch/i386/boot/compressed/vmlinux，setup,bootsect的区别与联系。

这几个可执行文件都是由 gcc 编译生成。只是格式不一样。

其中，helloworld,vmlinux,`arch/i386/boot/compressed/vmlinux` 都是 elf32_i386格式的可执行文件。setup，bootsect 是 binary 格式的可执行文件，它们的区别在于

* 1).helloworld 是普通的 elf32_i386 可执行文件。它的入口是_start。运行在用户态空间。变量的地址都是 32 位页式寻址的保护模式的地址，在用户态空间。由 shell 负责装载。
* 2).vmlinux 是未压缩的内核，它的入口是`startup_32`(0x100000，线性地址)，运行在内核态空间，变量的地址是 32 位页式寻址的保护模式的地址，在内核态空间。由内核自解压后启动运行。
* 3).arch/i386/boot/compressed/vmlinux 是压缩后的内核，它的入口地址是startup_32(0x100000，线性地址).运行在 32 位段式寻址的保护模式下，变量的地址是 32位段式寻址的保护模式的地址。由 setup 启动运行。
* 4).setup 是装载内核的 binary 格式的辅助程序。它的入口地址是：begtext（偏移地址为0。运行时需要把 cs 段寄存器设置为 0x9020）。运行在 16 位实地址模式下。变量的地址等于相对于代码段起始地址的偏移地址。由 boot loader 启动运行。
* 5).bootsect 是 MBR 上的引导程序，也为 binary 格式。它的入口地址是_start()，由于装载到 0x7c00 处，运行时需要把 cs 段寄存器设置为 0x7c0。运行在 16 位实地址模式下。变量地址等于相对于代码段起始地址的偏移地址。由 BIOS 启动运行。
