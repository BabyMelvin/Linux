如果系统调用的参数是错误的怎么办？如果参数仅仅是简单的整型，只要直接判断参数
范围就可以了，但是如果是指针呢？情况就复杂了。

如果指针为 null，是很容易判断的。如果指针不为 null，但是却指向非法的地址，该怎么办呢？如果在内核里段错误，内核就太冤了：明明是用户态程序的问题，却让我来背黑锅。。。
 
一种办法是在系统调用开始时就判断指针在不在用户空间里。进一步说，对指针指向的buffer 的每一个字节都要判断。这样可以提前检查出错误的参数，返回一个错误码。这样的缺点是太复杂，效率太低。因为出错的情况是少数。
针对这种情况，内核采用了 exception table。把所有可能出错的指令地址都放到exception table 中，与之对应的是一个错误处理函数。

例如，系统调用从用户态拷贝参数到内核态，要通过`copy_from_user()`。这个函数是用汇编写的。除了效率因素，还有一个原因是可以精确地判定出错指令的地址（即其中的一个 mov 指令）。fix code 则是一小段代码，它返回 0。于是，当 copy_from_user()出错时，在 page fault 处理函数里检查当前的 eip 是不是在 exception table 中（即那条 mov 指令），如果是的话，就跳到对应的 fix code（即返回为 0）。

这个方法兼顾了效率（不需要做额外的检查）和可靠性（保证用户程序的错误不会导致内核崩溃）。我们可以把 exception table 看作刑事档案，它告诉我们“某某某代码有前科，可能会有麻烦，请特别关照”。

这从另一个侧面告诉我们，内核中的代码对健壮性要求特别高。