# 计算机组成原理
> 1.处理器 2.主存储器 3.输入/输出模块 4.系统总线

## 1.处理器寄存器

寄存器是CPU的组成部分，因为在CPU内，所以CPU对其读写速度是最快的，不需要IO传输，
但同时也决定了此类寄存器数量非常有限，有限到几乎每个存储都有自己的名字，而且有些还有多个名字。

IA-32构架提供了16个基本寄存器，这16个基本寄存器可以归纳为如下几类:

* 通用寄存器
* 段寄存器
* 状态和控制寄存器
* 指令寄存器

其中寄存器：
* 用户可见寄存器：C语言中register
	* ` register char *d;`
	* register要是cpu能接受类型。
	* register变量可能不存放在内存中，不能用`&`来获取register变量地址。
	* 只有局部变量可以，其他不行（不能一直占用）
* 控制和状态寄存器
	* 程序计数器（pc）
	* 指令寄存器（IR，Instructions Register）
	
<center>
<image src="./image/01-1.png" height="50%" width="50%">
</center>

### 指令的执行

* 处理器最简单两步
	* 从存储器中读一条指令
	* 执行每条指令
* 一个单一指令需要处理称为一个指令周期

<center>
<image src="./image/01-2.png">
01-2基本指令周期
</center>

* 取指令和执行指令
	* 每个指令周期开始时，处理器从存储器中取一条指令。
		* 典型处理器中，程序计数器（PC）保存下一次要取得指令地址
		* 取到的指令被放在处理器的一个寄存器中，指令寄存器（IR）
	* 处理器解释指令并执行对应操作分为四类：
		* `处理器-存储器`：数据可以从处理器传送到存储器，或者从存储器传送到处理器。
		* `处理器-I/O`：通过处理器和I/O模块间的数据传送，数据可以输出到外部设备，或者从外部设备输入数据。
		* `数据处理`：处理器可以执行很多关于数据的算术操作或逻辑操作。
		* `控制`：某些指令可以改变执行顺序。（跳转）
* 中断和指令周期

<center>
<image src="./image/01-3.png">
01-3 中断和指令周期
</center>

## 中断处理

* 中断发生激活很多事件，包括处理器硬件中的事件和软件中事件
	* 需要保存从中断点恢复当前程序所需要的信息，要求的最少信息包括程序状态宇(PSW)和保存在程序计数器中的下一条要执行的指令地址，它们被压入系统控制栈中。
	* 处理器把响应此中断的中断处理器入口地址装入程序计数器中。可以是针对每类中断有一个中断处理器，或者是针对每个设备和每类中断各有一个中断处理器，这取决于计算机系统结构和操作系统的设计。
	* 有多个中断处理器，处理器就必须决定调用哪一个，这个信息可能已经包含在最初的中断信号中，否则处理器必须给发中断的设备发送请求，以获取含有所需信息的响应。

<center>
<image src="./image/01-4.png">
01-4 简单中断处理
</center>

* 多道程序设计
	* 提高CPU的利用率
### 2.存储器层次结构
* 存储器设计归结三个方面：
	* 存取时间越快，每“位”价格越高
	* 容量越大，每“位”价格就越低
	* 存量越大，存取速度就越慢
	
<center>
<image src="./image/01-5.png">
01-4 简单中断处理
</center>
	
* 多级存储可以实现，容量大，存储快。最成功关键：处理器访问存储器频率递减。
* 软件中可以有效增加额外存储层次，一部分主存储器作为缓冲区，用于临时保存从磁盘中读出的数据。磁盘高速缓冲存储器。两种方法来提高性能：
	* 磁盘成簇写。次数少，数据量大传输方式。
	* 下次一定会访问到数据，数据能够迅速从软件设置磁盘高速缓冲存储器中取出，而不是缓慢的磁盘中取回。
### 3.I/O通讯技术

* I/O操作有三种可能的技术：
	* 可编程I/O
	* 中断驱动I/O
	* 直接存储器访问（Direct Memory Access ,DMA）
#### 可编程I/O

如果使用这种技术，`处理器`负责从`主存储器`中`提取数据以用于输出`，并在`主存储器`中`保存数据以用于输入`。这是一个耗时的处理，处理器总是处于没有用的繁忙中。

处理器通常必须等待很长的时间，以确定I/O模块是否做好了接收或发送更多数据的准备。当处理器正在执行程序并遇到一个与I/O相关的指令时，它通过给相应的I/O模块发命令来执行这个指令。使用可编程I/O操作时，`I/O模块`执行请求的动作并设置I/O状态寄存器中相应的位，它`并不进一步通知处理器，尤其是它并不中断处理器`。

因此处理器在执行I/O指令后，还要定期检查I/O模块的状态，以确定I/O操作是否已经完成。
I/O软件应该设计为由处理器执行直接控制I/O操作的指令，包括检测设备状态、发送读命令或写命令和传送数据，因此指令集中包括以下几类I/O指令：

* `控制`：用于激活外部设备，并告诉它做什么。例如，可指示磁带倒退或前移一条记录。
* `状态`：用于测试与I/0模块及其外围设备相关的各种状态条件。
* `传送`：用于在存储器寄存器和外部设备间读数据或写数据。
#### 中断驱动I/O

`处理器`给`模块`发送`I/O命令`，然后继续做其他一些有用的工作。当I/0模块准备好与处理器交换数据时，它将打断处理器的执行并请求服务。

* I/O模块:输入操作，I/O模块从处理器中接收一个READ命令，然后开始从相关的外围设备读数据。一旦数据被读入该模块的数据寄存器，模块通过控制线给处理器发出一个中断信号，然后就等待，直到处理器请求该数据。当处理器发出这个请求后，模块把数据放到数据总线上，然后准备下一次I/O操作。
* 处理器：输入,处理器发一个READ命令，然后保存当前程序的上下文(如程序计数器和处理器寄存器)，离开当前程序，做其他事情(例如，处理器可以同时在几个不同的程序中工作)。在每个指令周期的末尾，处理器检查中断.当发生来自I/0模块的中断时，处理器保存当前正在执行的程序的上下文，开始执行中断处理程序处理此中断。

<center>
<image src="./image/01-6.png">
01-6
</center>

在某些系统中有多条中断线，这样每个模块就可在不同的线上发中断信号，每条中断线有不同的优先级。
当然，也可能只有一条中断线，但要使用额外的线来保存设备地址，而且不同的设备有不同的优先级。
#### 直接存储器访问

`I/O传送`速度受限于`处理器测试设备`和`提供服务的速度`。不论采用哪种形式，该技术的工作方式如下所示：当`处理器`要读或写一块数据时，它给`DMA模块`发出一条命令，发送以下信息：

* 是否请求一次读或写
* 涉及的I/O设备的地址
* 开始读或写的存储器单元
* 需要读或写的字数
处理器然后继续其他工作。`处理器`把这个`操作委托给DMA模块`，由该模块负责处理。`DMA模块`直接与`存储器`交互，传送整个数据块，每次传送一个字。这个过程不需要处理器参与。当传送完成后，`DMA模块`发一个`中断信号`给`处理器`。因此只有在开始传送和传送结束时处理器才会参与
**注意**，这并不是一个中断，处理器没有保存上下文去做别的事情，而是仅仅暂停一个总线周期(在总线上传输一个字的时间)。其总的影响是在DMA传送过程中，当处理器需要访问总线时处理器的执行速度会变慢。尽管如此，对多字I/O传送来说，DMA比中断驱动和程序控制I/O更有效。

## 寄存器与存储器的区别
现代的计算机主要包括三级存储，寄存器、内存储器和外存储器，存储数据的速率也依次递减。（外存储器不在本次讨论之中，姑且略过不讲）我们不妨将寄存器和内存储器都抽象成一个大的数组，其中的每个元素都有一个字节（8位）大小，CPU寻址的时候就是以该元素为最小单位完成的。如前一个元素的地址是0x1FFFFFF0的话，那么下一个元素的地址就是0x1FFFFFF1。我们可以理解为硬件构成上寄存器和内存储器也都是由一个8位大小的元器件线性排列组成的，地址对应着上面讲到的数组中元素的地址。到这里也许你能明白我的意思了，抛开存储速率不谈，对面向软件开发的人来说寄存器和内存储器结构可以看作是相同的，那它们有什么不同呢？

当然是存储速率不同了！先别骂街……速率只是表面现象，寄存器与内存本质的区别还是物理结构的不同，寄存器是有DFF（D触发器）构成的；内存储器有MOS门和TTL门两种构成。它们之间的具体区别跳过不讲，我只想让你知道二者之间在寻址原理上都是相同的！

## 外设内存映射机制
说到映射大家可能就会想到函数映射，脑海里会有一个画面：左边一个集合中的某个元素“射”出一条带箭头的直线指向右边的集合的某个元素。如果你高数或离散数学再好一点儿的话会想到单射、双射、满射、恒等映射（你要是这个都想到了，那你牛B！）……其实外围设备的内存映射原理是一样的，只不过左边的集体变成了CPU，右边的集合变成了外围设备，那条带箭头的线就是连接CPU和外设地址引脚的地址总线。

要知道，一个开发板的CPU地址引脚并不是所有的都与内存元器件相连的，如果该板上有外设（如一块独立显卡），那么CPU就需要分出一些引脚来与该外设的地址引脚相连，相当于将一部分内存寻址的空间分给了外设，那不相当于CPU分出去地址寻址空间为空？非也，一般的外设为了加快处理速度都有自己的片内RAM（比如说显存，你也知道显存对显卡性能的重要性），分出去的地址空间也就与片内RAM物理连接起来，这样CPU就能像访问内存一样去访问外设的片内RAM，这也就是所谓的内存映射（当然内存映射在程序设计中还有别的意思，但是这里的话，你懂的……）。

上面讲的都是RAM，那寄存器呢？之前啰哩啰嗦讲寄存器与内存的区别就是为了这里，我们得出的结论是二都在寻址原理上都是相同的，那寄存器看成是RAM不就行了！一样一样一样的！

其实这个知道了就很简单，但是当初我还懵懂的时候却天真的以为CPU先改变内存中的值，再通过一种什么神奇的机制让外设的RAM也变成相同的值……唉，没文化真可怕！