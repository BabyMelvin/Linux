# 中断处理
> 为什么需要中断?

* 1.外设的处理速度一般慢于CPU
* 2.CPU不能一直等待外部事件
所以设备**必须有一种方法来通知CPU它的工作进度**，这种方法叫做中断。
#### 中断实现
在Linux驱动实现程序中，为设备实现一个中断程序包含两个步骤：

* 1.向内核注册中断
* 2.实现中断处理函数
##### 中断注册
`request_irq`用于实现中断的注册功能：
`int request_irq(unsigned int irq,void(*handler)(int,void*,struct pt_regs*),unsigned long flags,const char *devname,void*dev_id)`返回0表示成功，或者返回一个错误码。

* unsigned int irq:中断号
* `void (*handler)(int,void*,struct pt_regs*)`中断处理函数
* `unsigned long flags`与中断管理有关的各项选项
	* `IRQF_DISABLED(SA_INTRERUPT)`如果设置该位，表示是一个`快速`中断处理程序；如果没有设置这位，那么是一个`慢速`中断处理程序.
	* `IRQF_SHARED(SA_SHIRQ)`该位表明中断可以在设备间共享。
* `const char*devname`设备名
* `void*dev_id`共享中断时使用

**快速/慢速中断**：快速中断保证中断处理的原子性(不被打断),
而慢速中断则不保证。换句话说，也就是"开启中断"标志位(处理器IF)在运行快速中断处理程序时是关闭的，因此在服务该中断时，不会被其他类型的中断打断；而调用慢速中断处理时，其他类型的中断仍可以得到服务。

**共享中断**就是将`不同的设备挂到同一个中断信号线上`。Linux对共享的支持主要是PCI设备服务。

共享中断也是通过`request_irq`函数来注册的，但是三个特别之处:

* 1.申请共享中断时，必须在flags参数中指定IRQF_SHARED位
* 2.`dev_id`:参数必须是唯一的。
* 3.共享中断的处理程序中，不能使用`disable_irq(unsigned int irq)`。因为使用了这个函数，共享中断信号线的其它设备将同样无法使用中断，也就无法正常工作了。

#### 中断处理程序
中断处理程序就是`普通的C代码`。特别在于中断处理程序是在`中断上下文`中运行的，它的行为受到某些限制：

* 1.不能向用户空间发送或接收数据
* 2.不能使用可能引起阻塞的函数
* 3.不能使用可能引起调度的函数

#### 中断处理函数流程

```c
void short_sh_interrupt(irq,void*dev,struct pt_regs*regs){
	//判断是否是本设备产生了中断
	value=inb(short_base);
	if!(value&0x80)return;
	//清楚中断位
	outb(value&0x7F,short_base);
	//中断处理，通常是数据接收
	
	//唤起等待数据的进程
	wake_up_interruptible(&short_queue);
}
```
#### 释放中断
当设备不再需要使用中断时(通常在驱动卸载时)，应当把他们返还给系统，使用:
```c
void free_irq(unsigned int irq,void*dev_id);