# 1.ARM Device Tree起源
Linus Torvalds在2011年3月17日的ARM Linux邮件列表宣称“this whole ARM thing is a f*cking pain in the ass”，引发ARM Linux社区的地震，随后ARM社区进行了一系列的重大修正。在过去的ARM Linux中，`arch/arm/plat-xxx和arch/arm/mach-xxx`中充斥着大量的垃圾代码，相当多数的代码只是在描述板级细节，而这些板级细节对于内核来讲，不过是垃圾，如板上的`platform设备`、`resource`、`i2c_board_info`、`spi_board_info`以及各种硬件的`platform_data`。

在Linux 2.6中，ARM架构的板极硬件细节过多地被硬编码在`arch/arm/plat-xxx`和`arch/arm/mach-xxx`，采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。

Device Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）：

* CPU的数量和类别
* 内存基地址和大小
* 总线和桥
* 外设连接
* `中断控制器`和`中断使用情况`
* `GPIO控制器`和`GPIO使用情况`
* `Clock控制器`和`Clock使用情况`

它基本上就是画一棵**电路板上CPU**、**总线**、**设备**组成的树，`Bootloader`会将这棵树传递给**内核**，然后内核可以识别这棵树，并根据它展开出Linux内核中的`platform_device`、`i2c_client`、`spi_device`等设备，而这些设备用到的`内存`、`IRQ`等资源，也被传递给了内核，**内核会将这些资源绑定给展开的相应的设备**。

# 2. Device Tree组成和结构
整个Device Tree牵涉面比较广，即增加了**新的用于描述设备硬件信息**的文本格式，又增加了**编译这一文本的工具**，同时Bootloader也需要支持将编译后的Device Tree传递给Linux内核。

## DTS (device tree source)

`.dts`文件是一种ASCII 文本格式的Device Tree描述，此文本格式非常人性化，适合人类的阅读习惯。基本上，在ARM Linux在，一个`.dts`文件对应一个ARM的machine，一般放置在内核的`arch/arm/boot/dts/`目录。由于一个SoC可能对应多个machine（一个SoC可以对应多个产品和电路板），势必这些`.dts`文件需包含许多共同的部分，Linux内核为了简化，把SoC公用的部分或者多个machine共同的部分一般提炼为`.dtsi`，类似于C语言的头文件。其他的machine对应的.dts就include这个`.dtsi`。譬如，对于VEXPRESS而言，vexpress-v2m.dtsi就被vexpress-v2p-ca9.dts所引用， vexpress-v2p-ca9.dts有如下一行：
`/include/ "vexpress-v2m.dtsi"`
当然，和C语言的头文件类似，`.dtsi`也可以include其他的`.dtsi`，譬如几乎所有的ARM SoC的`.dtsi`都引用了skeleton.dtsi。
`.dts`（或者其include的`.dtsi`）基本元素即为前文所述的结点和属性：

```
/ {
    node1 {
        a-string-property = "A string";
        a-string-list-property = "first string", "second string";
        a-byte-data-property = [0x01 0x23 0x34 0x56];
        child-node1 {
            first-child-property;
            second-child-property = <1>;
            a-string-property = "Hello, world";
        };
        child-node2 {
        };
    };
    node2 {
        an-empty-property;
        a-cell-property = <1 2 3 4>; /* each number (cell) is a uint32 */
        child-node1 {
        };
    };
};
```
上述`.dts`文件并没有什么真实的用途，但它基本表征了一个Device Tree源文件的结构：

* 1个root结点"/"；
* root结点下面含一系列子结点，本例中为"node1" 和 "node2"；
* 结点"node1"下又含有一系列子结点，本例中为"child-node1" 和 "child-node2"；
* 各结点都有一系列属性。这些属性可能为空，如" an-empty-property"；可能为字符串，如"a-string-property"；可能为字符串数组，如"a-string-list-property"；可能为Cells（由u32整数组成），如"second-child-property"，可能为二进制数，如"a-byte-data-property"。

## DTS例子

下面以一个最简单的machine为例来看如何写一个.dts文件。假设此machine的配置如下：

* 1个双核ARM Cortex-A9 32位处理器；
* ARM的local bus上的内存映射区域分布了2个串口（分别位于0x101F1000 和 0x101F2000）、GPIO控制器（位于0x101F3000）、SPI控制器（位于0x10170000）、中断控制器（位于0x10140000）和一个external bus桥；
* External bus桥上又连接了SMC SMC91111 Ethernet（位于0x10100000）、I2C控制器（位于0x10160000）、64MB NOR Flash（位于0x30000000）；External bus桥上连接的I2C控制器所对应的I2C总线上又连接了Maxim DS1338实时钟（I2C地址为0x58）。
其对应的.dts文件为：

```
/ {
    compatible = "acme,coyotes-revenge";
    #address-cells = <1>;
    #size-cells = <1>;
    interrupt-parent = <&intc>;
 
    cpus {
        #address-cells = <1>;
        #size-cells = <0>;
        cpu@0 {
            compatible = "arm,cortex-a9";
            reg = <0>;
        };
        cpu@1 {
            compatible = "arm,cortex-a9";
            reg = <1>;
        };
    };
 
    serial@101f0000 {
        compatible = "arm,pl011";
        reg = <0x101f0000 0x1000 >;
        interrupts = < 1 0 >;
    };
 
    serial@101f2000 {
        compatible = "arm,pl011";
        reg = <0x101f2000 0x1000 >;
        interrupts = < 2 0 >;
    };
 
    gpio@101f3000 {
        compatible = "arm,pl061";
        reg = <0x101f3000 0x1000
               0x101f4000 0x0010>;
        interrupts = < 3 0 >;
    };
 
    intc: interrupt-controller@10140000 {
        compatible = "arm,pl190";
        reg = <0x10140000 0x1000 >;
        interrupt-controller;
        #interrupt-cells = <2>;
    };
 
    spi@10115000 {
        compatible = "arm,pl022";
        reg = <0x10115000 0x1000 >;
        interrupts = < 4 0 >;
    };
 
    external-bus {
        #address-cells = <2>
        #size-cells = <1>;
        ranges = <0 0  0x10100000   0x10000     // Chipselect 1, Ethernet
                  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller
                  2 0  0x30000000   0x1000000>; // Chipselect 3, NOR Flash
 
        ethernet@0,0 {
            compatible = "smc,smc91c111";
            reg = <0 0 0x1000>;
            interrupts = < 5 2 >;
        };
 
        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            #address-cells = <1>;
            #size-cells = <0>;
            reg = <1 0 0x1000>;
            interrupts = < 6 2 >;
            rtc@58 {
                compatible = "maxim,ds1338";
                reg = <58>;
                interrupts = < 7 3 >;
            };
        };
 
        flash@2,0 {
            compatible = "samsung,k8f1315ebm", "cfi-flash";
            reg = <2 0 0x4000000>;
        };
    };
};
```
* 上述.dts文件中,root结点"/"的compatible 属性`compatible = "acme,coyotes-revenge";`定义了系统的名称，它的组织形式为：`<manufacturer>,<model>`。Linux内核透过root结点"/"的compatible 属性即可判断它启动的是什么machine。
在.dts文件的每个设备，都有一个compatible 属性，compatible属性用户驱动和设备的绑定。compatible 属性是一个字符串的列表，列表中的第一个字符串表征了结点代表的确切设备，形式为`"<manufacturer>,<model>"`，**其后的字符串表征可兼容的其他设备**。可以说前面的是特指，后面的则涵盖更广的范围。如在`arch/arm/boot/dts/vexpress-v2m.dtsi`中的Flash结点：

```
flash@0,00000000 {
     compatible = "arm,vexpress-flash", "cfi-flash";
     reg = <0 0x00000000 0x04000000>,
     <1 0x00000000 0x04000000>;
     bank-width = <4>;
 };
```
compatible属性的第2个字符串"cfi-flash"明显比第1个字符串"arm,vexpress-flash"涵盖的范围更广。再比如，Freescale MPC8349 SoC含一个串口设备，它实现了国家半导体（National Semiconductor）的ns16550 寄存器接口。则MPC8349串口设备的compatible属性为`compatible = "fsl,mpc8349-uart", "ns16550"`。其中，fsl,mpc8349-uart指代了确切的设备， ns16550代表该设备与National Semiconductor 的16550 UART保持了寄存器兼容。

* 接下来root结点"/"的cpus子结点下面又包含2个cpu子结点，描述了此machine上的2个CPU，并且二者的compatible 属性为"arm,cortex-a9"。注意cpus和cpus的2个cpu子结点的命名，它们遵循的组织形式为：`<name>[@<unit-address>]`，`<>`中的内容是必选项，`[]`中的则为可选项。name是一个ASCII字符串，用于描述结点对应的设备类型，如3com Ethernet适配器对应的结点name宜为ethernet，而不是3com509。如果一个结点描述的设备有地址，则应该给出@unit-address。多个相同类型设备结点的name可以一样，只要unit-address不同即可，如本例中含有cpu@0、cpu@1以及serial@101f0000与serial@101f2000这样的同名结点。设备的unit-address地址也经常在其对应结点的reg属性中给出。ePAPR标准给出了结点命名的规范。

* 可寻址的设备使用如下信息来在Device Tree中编码地址信息：
	*  `reg`:reg的组织形式为`reg = <address1 length1 [address2 length2] [address3 length3] ... >`，其中的每一组address length表明了设备使用的一个地址范围。address为1个或多个32位的整型（即cell），而length则为cell的列表或者为空（若`#size-cells = 0`）。address 和 length 字段是可变长的，父结点的`#address-cells`和`#size-cells`分别决定了子结点的reg属性的address和length字段的长度。
	*   `#address-cells`
	*   `#size-cells`

在本例中，root结点的`#address-cells = <1>;`和`#size-cells = <1>;`决定了serial、gpio、spi等结点的address和length字段的长度分别为1。cpus 结点的`#address-cells = <1>;`和`#size-cells = <0>;`决定了2个cpu子结点的address为1，而length为空，于是形成了2个cpu的`reg = <0>;`和`reg = <1>;`。external-bus结点的`#address-cells = <2>`和`#size-cells = <1>;`决定了其下的ethernet、i2c、flash的reg字段形如`reg = <0 0 0x1000>;`、`reg = <1 0 0x1000>;`和`reg = <2 0 0x4000000>;`。其中，address字段长度为0，开始的第一个cell（0、1、2）是对应的片选，第2个cell（0，0，0）是相对该片选的基地址，第3个cell（0x1000、0x1000、0x4000000）为length。特别要留意的是i2c结点中定义的 #address-cells = <1>;和#size-cells = <0>;又作用到了I2C总线上连接的RTC，它的address字段为0x58，是设备的I2C地址。

* root结点的子结点描述的是CPU的视图，因此root子结点的address区域就直接位于CPU的memory区域。但是，经过总线桥后的address往往需要经过转换才能对应的CPU的memory映射。external-bus的`ranges属性`定义了经过external-bus桥后的地址范围如何映射到CPU的memory区域。

```
ranges = <0 0  0x10100000   0x10000     // Chipselect 1, Ethernet
  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller
  2 0  0x30000000   0x1000000>; // Chipselect 3, NOR Flash
```
ranges是地址转换表，其中的每个项目是一个子地址、父地址以及在子地址空间的大小的映射。映射表中的子地址、父地址分别采用子地址空间的#address-cells和父地址空间的#address-cells大小。对于本例而言，子地址空间的#address-cells为2，父地址空间的#address-cells值为1，因此0 0  0x10100000   0x10000的前2个cell为external-bus后片选0上偏移0，第3个cell表示external-bus后片选0上偏移0的地址空间被映射到CPU的0x10100000位置，第4个cell表示映射的大小为0x10000。ranges的后面2个项目的含义可以类推。


Device Tree中还可以中断连接信息，对于中断控制器而言，它提供如下属性：

* `interrupt-controller` – 这个属性为空，中断控制器应该加上此属性表明自己的身份；
* `#interrupt-cells` – 与`#address-cells` 和 `#size-cells`相似，它表明连接此中断控制器的设备的interrupts属性的cell大小。

在整个Device Tree中，与中断相关的属性还包括：

* `interrupt-parent` – 设备结点透过它来指定它所依附的中断控制器的phandle，当结点没有指定interrupt-parent 时，则从父级结点继承。对于本例而言，root结点指定了`interrupt-parent = <&intc>;`其对应于`intc: interrupt-controller@10140000`，而root结点的子结点并未指定interrupt-parent，因此它们都继承了intc，即位于0x10140000的中断控制器。
* `interrupts` – 用到了中断的设备结点透过它指定中断号、触发方法等，具体这个属性含有多少个cell，由它依附的中断控制器结点的#interrupt-cells属性决定。而具体每个cell又是什么含义，一般由驱动的实现决定，而且也会在Device Tree的binding文档中说明。譬如，对于ARM GIC中断控制器而言，`#interrupt-cells`为3，它3个cell的具体含义`Documentation/devicetree/bindings/arm/gic.txt`就有如下文字说明：

```
01   The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPI
02   interrupts.
03
04   The 2nd cell contains the interrupt number for the interrupt type.
05   SPI interrupts are in the range [0-987].  PPI interrupts are in the
06   range [0-15].
07
08   The 3rd cell is the flags, encoded as follows:
09         bits[3:0] trigger type and level flags.
10                 1 = low-to-high edge triggered
11                 2 = high-to-low edge triggered
12                 4 = active high level-sensitive
13                 8 = active low level-sensitive
14         bits[15:8] PPI interrupt cpu mask.  Each bit corresponds to each of
15         the 8 possible cpus attached to the GIC.  A bit set to '1' indicated
16         the interrupt is wired to that CPU.  Only valid for PPI interrupts.
```
另外，值得注意的是，一个设备还可能用到多个中断号。对于ARM GIC而言，若某设备使用了SPI的168、169号2个中断，而言都是高电平触发，则该设备结点的interrupts属性可定义为：`interrupts = <0 168 4>, <0 169 4>;`
除了中断以外，在ARM Linux中clock、GPIO、pinmux都可以透过.dts中的结点和属性进行描述。

## DTC (device tree compiler)
将.dts编译为.dtb的工具。DTC的源代码位于内核的scripts/dtc目录，在Linux内核使能了Device Tree的情况下，编译内核的时候主机工具dtc会被编译出来，对应scripts/dtc/Makefile中的“hostprogs-y := dtc”这一hostprogs编译target。
在Linux内核的arch/arm/boot/dts/Makefile中，描述了当某种SoC被选中后，哪些.dtb文件会被编译出来，如与VEXPRESS对应的.dtb包括：

```
dtb-$(CONFIG_ARCH_VEXPRESS) += vexpress-v2p-ca5s.dtb \
        vexpress-v2p-ca9.dtb \
        vexpress-v2p-ca15-tc1.dtb \
        vexpress-v2p-ca15_a7.dtb \
        xenvm-4.2.dtb
```
在Linux下，我们可以单独编译Device Tree文件。当我们在Linux内核下运行`make dtbs`时，若我们之前选择了ARCH_VEXPRESS，上述`.dtb`都会由对应的`.dts`编译出来。因为`arch/arm/Makefile`中含有一个dtbs编译target项目。

## Device Tree Blob (.dtb)
`.dtb`是`.dts`被DTC编译后的二进制格式的Device Tree描述，可由Linux内核解析。通常在我们为电路板制作NAND、SD启动image时，会为`.dtb`文件单独留下一个很小的区域以存放之，之后bootloader在引导kernel的过程中，会先读取该`.dtb`到内存。

## Binding
对于Device Tree中的结点和属性具体是如何来描述设备的硬件细节的，一般需要文档来进行讲解，文档的后缀名一般为`.txt`。这些文档位于内核的`Documentation/devicetree/bindings`目录，其下又分为很多子目录。

## Bootloader
Uboot mainline 从 v1.1.3开始支持Device Tree，其对ARM的支持则是和ARM内核支持Device Tree同期完成。
为了使能Device Tree，需要编译Uboot的时候在config文件中加入
`#define CONFIG_OF_LIBFDT `
在Uboot中，可以从NAND、SD或者TFTP等任意介质将`.dtb`读入内存，假设`.dtb`放入的内存地址为`0x71000000`，之后可在Uboot运行命令`fdt addr`命令设置`.dtb`的地址，如：
`U-Boot> fdt addr 0x71000000`
fdt的其他命令就变地可以使用，如`fdt resize`、fdt print等。
对于ARM来讲，可以透过bootz kernel_addr initrd_address dtb_address的命令来启动内核，即dtb_address作为bootz或者bootm的最后一次参数，第一个参数为内核映像的地址，第二个参数为initrd的地址，若不存在initrd，可以用 -代替。

# 3.Device Tree引发的BSP和驱动变更

有了Device Tree后，大量的板级信息都不再需要，譬如过去经常在`arch/arm/plat-xxx`和`arch/arm/mach-xxx`实施的如下事情：

1.注册platform_device，绑定resource，即内存、IRQ等板级信息。透过Device Tree后，形如

```
90 static struct resource xxx_resources[] = {
91         [0] = {
92                 .start  = …,
93                 .end    = …,
94                 .flags  = IORESOURCE_MEM,
95         },
96         [1] = {
97                 .start  = …,
98                 .end    = …,
99                 .flags  = IORESOURCE_IRQ,
100         },
101 };
102
103 static struct platform_device xxx_device = {
104         .name           = "xxx",
105         .id             = -1,
106         .dev            = {
107                                 .platform_data          = &xxx_data,
108         },
109         .resource       = xxx_resources,
110         .num_resources  = ARRAY_SIZE(xxx_resources),
111 };
```