内核代码的一个核心问题是不但**能够存取已知长度的数据项**(例如, 文件系统数据结构或者设备单板上的寄存器), 而且可以使用不同**处理器的能力**(32-位 和 64-位 体系, 并且也可能是 16 位).

坚持严格的数据类型和使用`-Wall -Wstrict-prototypes`进行编译可能避免大部分的 bug.

内核数据使用的数据类型分为 3 个主要类型: 

* 标准 C 类型例如 int.
* 明确大小的类型例如 u32
* 以及用作特定内核对象的类型, 例如 pid_t. 

# 1.标准 C 类型的使用
模糊数据类型，可能带来移植的bug。内核中通常的内存地址常常是`unsigned long`, 利用了`指针`和`长整型`一直是相同大小的这个事实, 至少在 Linux 目前支持的所有平台上.

# 2.安排一个明确大小给数据项
有时内核代码需要一个特定大小的数据项,内核提供了下列数据类型来使用, 无论你什么时候需要知道你的数据的大小. 所有的数据声明在`<asm/types.h>`, 它又被`<linux/types.h>`包含.

```c
u8;   /* unsigned byte (8 bits) */
u16;  /* unsigned word (16 bits) */
u32;  /* unsigned 32-bit value */
u64;  /* unsigned 64-bit value */
```
存在对应的有符号类型, 但是很少需要; 如果你需要它们, 只要在名子里用`s`代替`u`.

如果一个**用户空间程序**需要使用这些类型, 可用使用一个`双下划线前缀`在名子上:`__u8`和其它独立于`__KERNEL__`定义的类型. 例如, 如果, 一个驱动需要与用户空间中运行的程序交换二进制结构, 通过 ioctl, 头文件应当在结构中声明 32-位 成员为`__u32`.


重要的是记住这些类型是**Linux特定的**, 并且使用它们妨碍了移植软件到其他的 Unix上. 使用近期编译器的系统支持C99-标准类型, 例如`uint8_t`和`uint32_t;`.**如果考虑到移植性**,**使用这些类型比 Linux-特定的变体要好**.

# 3.接口特定的类型

内核中一些通常使用的数据类型有它们自己的 typedef 语句, 因此阻止了任何移植性问题. 例如, 一个进程标识符 ( pid ) 常常是`pid_t`而不是int. 使用`pid_t`屏蔽了任何在实际数据类型上的不同. 

无论何时你的驱动使用需要这样"定制"类型的函数并且你不遵照惯例, 编译器发出一个警告; 如果你使用 `-Wall`编译器标志并且小心去除所有的警告, 你能有信心你的代码是可移植的.

`_t`数据项的主要问题是当你需要打印它们时, 常常不容易选择正确的 printk 或 printf 格式, 无论何时你需要打印某个接口特定的数据, 最好的方法是转换它的值为最大的可能类型(常常是 long 或者 unsigned long ) 并且接着打印它通过对应的格式.这种调整不会产生错误或者警告, 因为格式匹配类型, 并且你不会丢失数据位, 因为这个转换或者是一个空操作或者是数据项向更大数据类型的扩展.

# 4.其他移植性问题
除了数据类型, 当编写一个驱动时有几个其他的软件问题要记住,。一个通常的规则是怀疑显式的常量值. 常常通过使用预处理宏, 代码已被参数化。无论何时你遇到已被参数化的值, 你可以在头文件中以及在随官方内核发布的设备驱动中找到提示.

## 4.1 时间间隔
当涉及时间间隔, 不要假定每秒有 1000 个嘀哒. 尽管当前对 i386 体系是真实的, 不是每个 Linux 平台都以这个速度运行. 对于 x86 如果你使用 HZ 值(如同某些人做的那样), 这个假设可能是错的, 并且没人知道将来内核会发生什么. 无论何时你使用嘀哒来计算时间间隔, 使用 HZ ( 每秒的定时器中断数 ) 来标定你的时间. 例如, 检查一个半秒的超时, 用`HZ/2`和逝去时间比较. 更普遍地, msec 毫秒对应地嘀哒数一直是`msec*HZ/1000`.

## 4.2 页大小
当使用内存时, **记住一个内存页是 PAGE_SIZE 字节**, **不是 4KB**.假定页大小是 4KB 并且硬编码这个值是一个 PC 程序员常见的错误, 相反, 被支持的平台显示页大小从 4 KB 到 64 KB, 并且有时它们在相同平台上的不同的实现上不同.

相关的宏定义是 PAGE_SIZE 和 PAGE_SHIT. 后者包含将一个地址移位来获得它的页号的位数. 对于 4KB 或者更大的页这个数当前是 12 或者更大.宏在`<asm/page.h>`中定义; 用户空间程序可以使用 `getpagesize`库函数, 如果它们需要这个信息.

让我们看一下非一般的情况. 如果一个驱动需要16KB来暂存数据, 它不应当指定一个2的指数给 `get_free_pages`. 你需要一个可移植解决方法. 这样的解决方法, 幸运的是, 已经由内核开发者写好并且称为 get_order:

```c
#include <asm/page.h>
int order = get_order(16*1024);
buf = get_free_pages(GFP_KERNEL, order);
```
记住, `get_order`的参数必须是 2 的幂.

## 4.3 字节序
小心不要假设字节序. PC 存储多字节值是低字节为先(小端为先, 因此是小端), 一些高级的平台以另一种方式(大端)工作. 任何可能的时候, 你的代码应当这样来编写, 它不在乎它操作的数据的字节序. 但是, 有时候一个驱动需要使用单个字节建立一个整型数或者相反, 或者它必须与一个要求一个特定顺序的设备通讯.

包含文件`<asm/byteorder.h>`定义了或者`__BIG_ENDIAN`或者`__LITTLE_ENDIAN`, 依赖处理器的字节序. 当处理字节序问题时, 你可能编码一堆 `#ifdef __LITTTLE_ENDIAN`条件语句, 但是有一个更好的方法. Linux 内核定义了一套宏定义来处理之间的转换, 在处理器字节序和你需要以特定字节序存储和加载的数据之间. 例如:

```c
u32 cpu_to_le32 (u32);
u32 le32_to_cpu (u32);
```
这 2 个宏定义转换一个值, 从无论 CPU 使用的什么到一个无符号的, 小端, 32 位数, 并且转换回. 它们不管你的 CPU 是小端还是大端, 不管它是不是 32-位 处理器. 在没有事情要做的情况下它们原样返回它们的参数. 使用这些宏定义易于编写可移植的代码, 而不必使用大量的条件编译建造.

有很多类似的函数; 你可以在 <linux/byteorder/big_endian.h> 和 <linux/byteorder/little_endian.h> 中见到完整列表. 一会儿之后, 这个模式不难遵循. be64_to_cpu 转换一个无符号的, 大端, 64-位 值到一个内部 CPU 表示. le16_to_cpus, 相反, 处理有符号的, 小端, 16 位数. 当处理指针时, 你也会使用如 cpu_to_le32p, 它使用指向一个值的指针来转换, 而不是这个值自身. 剩下的看包含文件.

## 4.4 数据对齐

编写可移植代码而值得考虑的最后一个问题是如何存取不对齐的数据 -- 例如, 如何读取一个存储于一个不是 4 字节倍数的地址的4字节值. i386 用户常常存取不对齐数据项, 但是不是所有的体系允许这个. 很多现代的体系产生一个异常, 每次程序试图不对齐数据传送时; 数据传输由异常处理来处理, 带来很大的性能牺牲. 如果你需要存取不对齐的数据, 你应当使用下列宏:

```c
#include <asm/unaligned.h>
get_unaligned(ptr);
put_unaligned(val, ptr);
```
这些宏是无类型的, 并且用在每个数据项, 不管它是 1 个, 2 个, 4 个, 或者 8 个字节长. 它们在任何内核版本中定义.
