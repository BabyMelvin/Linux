# 1.线程概念

* 技术上，线程可以定义为：可以被操作系统调度的独立的指令流。
* 线程使用并存在于进程资源中，还可以被操作系统调用并独立地运行，这主要是因为线程仅仅复制必要的资源以使自己得以存在并执行。 
* 独立的控制流得以实现是因为线程维持着自己的：
  * 堆栈指针 
  * 寄存器 
  * 调度属性（如：策略或优先级）
  * 待定的和阻塞的信号集合（Set of pending and blocked signals） 
  * 线程专用数据（TSD：Thread Specific Data.） 

因此，在UNIX环境下线程：

* 存在于进程，使用进程资源 
* 拥有自己独立的控制流，只要父进程存在并且操作系统支持 
* 只复制必可以使得独立调度的必要资源 
* 可以和其他线程独立（或非独立的）地共享进程资源 
* 当父进程结束时结束，或者相关类似的 
* 是“轻型的”，因为大部分额外开销已经在进程创建时完成了

因为在同一个进程中的线程共享资源：

* 一个线程对系统资源（如关闭一个文件）的改变对所有其它线程是可以见的 
* 两个**同样值的指针**指向相同的数据
* 读写同一个内存位置是可能的，因此需要成员显式地使用同步 

# 2.pthread优势

使用Pthreads的主要动机是提高潜在程序的性能。

* 当与创建和管理**进程的花费相比**，线程可以使用操作系统较少的开销，管理线程需要较少的系统资源。
* 在同一个进程中的所有线程**共享同样的地址空间**。较于进程间的通信，在许多情况下线程间的通信效率比较高，且易于使用。
* 较于没有使用线程的程序，使用线程的应用程序有潜在的性能增益和实际的优点： 
  * CPU使用I/O交叠工作：例如，一个程序可能有一个需要较长时间的I/O操作，当一个线程等待I/O系统调用完成时，CPU可以被其它线程使用。
  * `优先/实时调度`：比较重要的任务可以被调度，替换或者中断较低优先级的任务。
  * 异步事件处理：频率和持续时间不确定的任务可以交错。例如，web服务器可以同时为前一个请求传输数据和管理新请求。
  * 考虑在SMP架构上使用Pthreads的主要动机是获的最优的性能。特别的，如果一个程序使用MPI在节点通信，使用Pthreads可以使得节点数据传输得到显著提高。 
    * MPI库经常用共享内存实现节点任务通信，这至少需要一次内存复制操作（进程到进程）。 
    * Pthreads没有中间的内存复制，因为线程和一个进程共享同样的地址空间。没有数据传输。变成cache-to-CPU或memory-to-CPU的带宽（最坏情况），速度是相当的快。 

# 3.Pthreads使用
## 3.1 并行编程
在现代多CPU机器上，pthread非常适于并行编程。可以用于并行程序设计的，也可以用于pthread程序设计。


[Introduction to Parallel Computing](https://computing.llnl.gov/tutorials/parallel_comp/)并行
程序要考虑许多，如下：

* 用什么并行程序设计模型？ 
* 问题划分 
* 加载平衡（Load balancing）
* 通信 
* 数据依赖 
* 同步和竞争条件 
* 内存问题 
* `I/O`问题 
* 程序复杂度 
* 程序员的`努力/花费/时间`

拥有下述特性的程序可以使用pthreads：

* 工作可以被多个任务同时执行，或者数据可以同时被多个任务操作。 
* 阻塞与潜在的长时间`I/O`等待。 
* 在某些地方使用很多CPU循环而其他地方没有。 
* 对异步事件必须响应。 
* 一些工作比其他的重要（优先级中断）。 

Pthreads 也可以用于串行程序，模拟并行执行。很好例子就是经典的web浏览器，对于多数人，运行于单CPU的桌面/膝上机器，许多东西可以同时“显示”出来。 

使用线程编程的几种常见模型：

* `管理者/工作者`（Manager/worker）：一个单线程，作为管理器将工作分配给其它线程（工作者），典型的，管理器处理所有输入和分配工作给其它任务。至少两种形式的`manager/worker`模型比较常用：静态worker池和动态worker池。 
* 管道（Pipeline）：任务可以被划分为一系列子操作，每一个被串行处理，但是不同的线程并发处理。汽车装配线可以很好的描述这个模型。 
* Peer: 和`manager/worker`模型相似，但是主线程在创建了其它线程后，自己也参与工作。 
* 共享内存模型（Shared Memory Model）: 
  * 所有线程可以访问全局，共享内存 
  * 线程也有自己私有的数据 
  * 程序员负责对全局共享数据的同步存取（保护） 

## 3.2 线程安全(Thread-safeness)
线程安全：简短的说，指程序可以同时执行多个线程却不会“破坏“共享数据或者产生“竞争”条件的能力。 

假设你的程序创建了几个线程，每一个调用相同的库函数：

* 这个库函数存取/修改了一个全局结构或内存中的位置。 
* 当每个线程调用这个函数时，可能同时去修改这个全局结构活内存位置。 
* 如果函数没有使用同步机制去阻止数据破坏，这时，就不是线程安全的了。 


如果你不是100%确定外部库函数是线程安全的，自己负责所可能引发的问题。 

建议：小心使用库或者对象，当不能明确确定是否是线程安全的。若有疑虑，假设其不是线程安全的直到得以证明。可以通过不断地使用不确定的函数找出问题所在。 

来自:[GAME-LAB](https://www.cnblogs.com/mywolrd/archive/2009/02/05/1930707.html#ref)